<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/MainActivity.kt" />
              <option name="originalContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import de.fampopprol.dhbwhorb.data.cache.TimetableCacheManager&#10;import de.fampopprol.dhbwhorb.data.dualis.network.DualisService&#10;import de.fampopprol.dhbwhorb.data.security.CredentialManager&#10;import de.fampopprol.dhbwhorb.data.notification.ScheduleChangeManager&#10;import de.fampopprol.dhbwhorb.ui.screen.*&#10;import de.fampopprol.dhbwhorb.ui.theme.DHBWHorbTheme&#10;import de.fampopprol.dhbwhorb.widget.WidgetUpdateManager&#10;import de.fampopprol.dhbwhorb.ui.components.CalendarViewMode&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;&#10;        // Debug the cache contents first&#10;        val cacheManager = TimetableCacheManager(this)&#10;        cacheManager.debugCacheContents()&#10;&#10;        // Manually refresh widgets on app start to ensure they show current data&#10;        Log.d(&quot;MainActivity&quot;, &quot;Manually refreshing widgets on app start&quot;)&#10;        WidgetUpdateManager.updateAllWidgets(this)&#10;&#10;        // Initialize schedule change monitoring&#10;        val scheduleChangeScheduler = ScheduleChangeManager(this)&#10;        scheduleChangeScheduler.startPeriodicChecking()&#10;        Log.d(&quot;MainActivity&quot;, &quot;Schedule change monitoring started&quot;)&#10;&#10;        setContent {&#10;            var currentTimetableScreenViewMode by remember { mutableStateOf(CalendarViewMode.WEEKLY) }&#10;&#10;            val onTimetableScreenViewModeChanged: (CalendarViewMode) -&gt; Unit = { newMode -&gt;&#10;                currentTimetableScreenViewMode = newMode&#10;            }&#10;&#10;            App(&#10;                currentTimetableScreenViewMode = currentTimetableScreenViewMode,&#10;                onTimetableScreenViewModeChanged = onTimetableScreenViewModeChanged&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun LoginScreenPreview() {&#10;    DHBWHorbTheme {&#10;        LoginScreen(&#10;            dualisService = DualisService(),&#10;            credentialManager = CredentialManager(LocalContext.current),&#10;            onLoginSuccess = {}&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun TimetableScreenPreview() {&#10;    DHBWHorbTheme {&#10;        TimetableScreen(&#10;            dualisService = DualisService(),&#10;            credentialManager = CredentialManager(LocalContext.current),&#10;            timetableCacheManager = TimetableCacheManager(LocalContext.current),&#10;            onLogout = {},&#10;            currentViewMode = CalendarViewMode.WEEKLY, // Dummy value for preview&#10;            onViewModeChanged = {} // Dummy value for preview&#10;        )&#10;    }&#10;}" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import de.fampopprol.dhbwhorb.data.cache.TimetableCacheManager&#10;import de.fampopprol.dhbwhorb.data.dualis.network.DualisService&#10;import de.fampopprol.dhbwhorb.data.security.CredentialManager&#10;import de.fampopprol.dhbwhorb.data.notification.ScheduleChangeManager&#10;import de.fampopprol.dhbwhorb.ui.screen.*&#10;import de.fampopprol.dhbwhorb.ui.theme.DHBWHorbTheme&#10;import de.fampopprol.dhbwhorb.widget.WidgetUpdateManager&#10;import de.fampopprol.dhbwhorb.ui.components.CalendarViewMode&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;&#10;        // Debug the cache contents first&#10;        val cacheManager = TimetableCacheManager(this)&#10;        cacheManager.debugCacheContents()&#10;&#10;        // Manually refresh widgets on app start to ensure they show current data&#10;        Log.d(&quot;MainActivity&quot;, &quot;Manually refreshing widgets on app start&quot;)&#10;        WidgetUpdateManager.updateAllWidgets(this)&#10;&#10;        // Initialize schedule change monitoring&#10;        val scheduleChangeManager = ScheduleChangeManager(this)&#10;        scheduleChangeManager.initialize()&#10;        Log.d(&quot;MainActivity&quot;, &quot;Schedule change monitoring initialized&quot;)&#10;&#10;        setContent {&#10;            var currentTimetableScreenViewMode by remember { mutableStateOf(CalendarViewMode.WEEKLY) }&#10;&#10;            val onTimetableScreenViewModeChanged: (CalendarViewMode) -&gt; Unit = { newMode -&gt;&#10;                currentTimetableScreenViewMode = newMode&#10;            }&#10;&#10;            App(&#10;                currentTimetableScreenViewMode = currentTimetableScreenViewMode,&#10;                onTimetableScreenViewModeChanged = onTimetableScreenViewModeChanged&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun LoginScreenPreview() {&#10;    DHBWHorbTheme {&#10;        LoginScreen(&#10;            dualisService = DualisService(),&#10;            credentialManager = CredentialManager(LocalContext.current),&#10;            onLoginSuccess = {}&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun TimetableScreenPreview() {&#10;    DHBWHorbTheme {&#10;        TimetableScreen(&#10;            dualisService = DualisService(),&#10;            credentialManager = CredentialManager(LocalContext.current),&#10;            timetableCacheManager = TimetableCacheManager(LocalContext.current),&#10;            onLogout = {},&#10;            currentViewMode = CalendarViewMode.WEEKLY, // Dummy value for preview&#10;            onViewModeChanged = {} // Dummy value for preview&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/dualis/models/DualisUrl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/dualis/models/DualisUrl.kt" />
              <option name="originalContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.data.dualis.models&#10;&#10;data class DualisUrl(&#10;    var mainPageUrl: String? = null,&#10;    var logoutUrl: String? = null,&#10;    var studentResultsUrl: String? = null,&#10;    var courseResultUrl: String? = null,&#10;    var monthlyScheduleUrl: String? = null,&#10;)" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.data.dualis.models&#10;&#10;data class DualisUrl(&#10;    var mainPageUrl: String? = null,&#10;    var logoutUrl: String? = null,&#10;    var studentResultsUrl: String? = null,&#10;    var courseResultUrl: String? = null,&#10;    var monthlyScheduleUrl: String? = null,&#10;    var notificationsUrl: String? = null,&#10;    val semesterCourseResultUrls: MutableMap&lt;String, String&gt; = mutableMapOf(),&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/dualis/models/Notification.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/dualis/models/Notification.kt" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.data.dualis.models&#10;&#10;/**&#10; * Represents a notification from Dualis&#10; */&#10;data class Notification(&#10;    val id: String,&#10;    val date: String,&#10;    val time: String,&#10;    val sender: String,&#10;    val subject: String,&#10;    val type: NotificationType,&#10;    val isUnread: Boolean,&#10;    val detailUrl: String?,&#10;    val deleteUrl: String?&#10;)&#10;&#10;/**&#10; * Types of notifications that can be received from Dualis&#10; */&#10;enum class NotificationType {&#10;    SCHEDULE_CHANGE,&#10;    SCHEDULE_SET,&#10;    GENERAL_MESSAGE,&#10;    UNKNOWN&#10;}&#10;&#10;/**&#10; * Container for notification data&#10; */&#10;data class NotificationList(&#10;    val unreadNotifications: List&lt;Notification&gt;,&#10;    val totalUnreadCount: Int&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/dualis/network/DualisHtmlParser.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/dualis/network/DualisHtmlParser.kt" />
              <option name="originalContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.data.dualis.network&#10;&#10;import android.util.Log&#10;import de.fampopprol.dhbwhorb.data.dualis.models.DualisUrl&#10;import de.fampopprol.dhbwhorb.data.dualis.models.Semester&#10;import de.fampopprol.dhbwhorb.data.dualis.models.TimetableDay&#10;import de.fampopprol.dhbwhorb.data.dualis.models.TimetableEvent&#10;import de.fampopprol.dhbwhorb.data.dualis.models.Notification&#10;import de.fampopprol.dhbwhorb.data.dualis.models.NotificationType&#10;import de.fampopprol.dhbwhorb.data.dualis.models.NotificationList&#10;import org.jsoup.Jsoup&#10;import java.time.format.DateTimeFormatter&#10;&#10;/**&#10; * Handles HTML parsing operations for Dualis responses&#10; */&#10;class DualisHtmlParser {&#10;&#10;    /**&#10;     * Parses the main page to extract Dualis URLs&#10;     */&#10;    fun parseMainPage(html: String, authToken: String?): DualisUrl {&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;=== PARSING REAL MAIN PAGE ===&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;HTML length: ${html.length}&quot;)&#10;&#10;        val document = Jsoup.parse(html)&#10;        val dualisUrls = DualisUrl()&#10;        val dualisEndpoint = &quot;https://dualis.dhbw.de&quot;&#10;&#10;        // Log all links for debugging&#10;        val allLinks = document.select(&quot;a&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Found ${allLinks.size} total links in main page&quot;)&#10;&#10;        // Construct the COURSERESULTS URL using the auth token&#10;        if (authToken != null) {&#10;            val baseUrl = &quot;https://dualis.dhbw.de/scripts/mgrqispi.dll?APPNAME=CampusNet&amp;PRGNAME=COURSERESULTS&amp;ARGUMENTS=-N$authToken,-N000307,&quot;&#10;            dualisUrls.studentResultsUrl = baseUrl&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Constructed student results URL: ${dualisUrls.studentResultsUrl}&quot;)&#10;        }&#10;&#10;        // Extract course result URL&#10;        val courseResultElement = document.select(&quot;a:contains(Prüfungsergebnisse)&quot;).first()&#10;        if (courseResultElement != null) {&#10;            val rawHref = courseResultElement.attr(&quot;href&quot;)&#10;            dualisUrls.courseResultUrl = if (rawHref.startsWith(&quot;/&quot;)) dualisEndpoint + rawHref else rawHref&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Found course results URL: ${dualisUrls.courseResultUrl}&quot;)&#10;        }&#10;&#10;        // Extract monthly schedule URL&#10;        val monthlyScheduleElement = document.select(&quot;a:contains(diese Woche)&quot;).first()&#10;        if (monthlyScheduleElement != null) {&#10;            val rawHref = monthlyScheduleElement.attr(&quot;href&quot;)&#10;            dualisUrls.monthlyScheduleUrl = if (rawHref.startsWith(&quot;/&quot;)) dualisEndpoint + rawHref else rawHref&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Found schedule URL: ${dualisUrls.monthlyScheduleUrl}&quot;)&#10;        }&#10;&#10;        // Extract logout URL&#10;        val logoutElement = document.select(&quot;a:contains(Abmelden)&quot;).first()&#10;        if (logoutElement != null) {&#10;            val rawHref = logoutElement.attr(&quot;href&quot;)&#10;            dualisUrls.logoutUrl = if (rawHref.startsWith(&quot;/&quot;)) dualisEndpoint + rawHref else rawHref&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Found logout URL: ${dualisUrls.logoutUrl}&quot;)&#10;        }&#10;&#10;        // Extract notifications URL - look for &quot;Nachrichten&quot; link&#10;        val notificationsElement = document.select(&quot;a:contains(Nachrichten)&quot;).first()&#10;        if (notificationsElement != null) {&#10;            val rawHref = notificationsElement.attr(&quot;href&quot;)&#10;            dualisUrls.notificationsUrl = if (rawHref.startsWith(&quot;/&quot;)) dualisEndpoint + rawHref else rawHref&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Found notifications URL: ${dualisUrls.notificationsUrl}&quot;)&#10;        }&#10;&#10;        return dualisUrls&#10;    }&#10;&#10;    /**&#10;     * Checks if the HTML content represents the main page&#10;     */&#10;    fun isMainPage(html: String): Boolean {&#10;        val document = Jsoup.parse(html)&#10;        // Check for elements that are typically present on the main page&#10;        return document.select(&quot;a:contains(Prüfungsergebnisse)&quot;).isNotEmpty() ||&#10;               document.select(&quot;a:contains(diese Woche)&quot;).isNotEmpty() ||&#10;               document.select(&quot;a:contains(Abmelden)&quot;).isNotEmpty()&#10;    }&#10;&#10;    /**&#10;     * Checks if the response indicates an invalid token&#10;     */&#10;    fun isTokenInvalidResponse(html: String): Boolean {&#10;        return html.contains(&quot;Session ist abgelaufen&quot;) ||&#10;               html.contains(&quot;Session expired&quot;) ||&#10;               html.contains(&quot;Anmeldung erforderlich&quot;) ||&#10;               html.contains(&quot;Login required&quot;) ||&#10;               html.contains(&quot;LOGINCHECK&quot;)&#10;    }&#10;&#10;    /**&#10;     * Parses semester information from HTML&#10;     */&#10;    fun parseSemestersFromHtml(html: String): List&lt;Semester&gt; {&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;=== PARSING SEMESTERS FROM HTML ===&quot;)&#10;&#10;        val document = Jsoup.parse(html)&#10;        val semesters = mutableListOf&lt;Semester&gt;()&#10;&#10;        // Look for semester select dropdown&#10;        val semesterSelect = document.select(&quot;select#semester&quot;).first()&#10;&#10;        if (semesterSelect != null) {&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Found semester select dropdown&quot;)&#10;&#10;            val options = semesterSelect.select(&quot;option&quot;)&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Found ${options.size} semester options&quot;)&#10;            val semesterOptions = mutableListOf&lt;Triple&lt;String, String, Boolean&gt;&gt;()&#10;&#10;            options.forEach { option -&gt;&#10;                val value = option.attr(&quot;value&quot;)&#10;                val displayName = option.text().trim()&#10;                val isSelected = option.hasAttr(&quot;selected&quot;)&#10;&#10;                if (value.isNotEmpty() &amp;&amp; displayName.isNotEmpty()) {&#10;                    semesterOptions.add(Triple(value, displayName, isSelected))&#10;                    Log.d(&quot;DualisHtmlParser&quot;, &quot;Found semester option: $displayName (value: $value, selected: $isSelected)&quot;)&#10;                }&#10;            }&#10;&#10;            // Use the new factory method to create semesters from Dualis data&#10;            if (semesterOptions.isNotEmpty()) {&#10;                val dynamicSemesters = Semester.fromDualisOptions(semesterOptions)&#10;                semesters.addAll(dynamicSemesters)&#10;                Log.d(&quot;DualisHtmlParser&quot;, &quot;Created ${dynamicSemesters.size} semesters from Dualis data&quot;)&#10;            } else {&#10;                Log.w(&quot;DualisHtmlParser&quot;, &quot;No valid semester options found, using defaults&quot;)&#10;                semesters.addAll(Semester.getDefaultSemesters())&#10;            }&#10;        } else {&#10;            Log.w(&quot;DualisHtmlParser&quot;, &quot;No semester select dropdown found, using defaults&quot;)&#10;            semesters.addAll(Semester.getDefaultSemesters())&#10;        }&#10;&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Final semester list:&quot;)&#10;        semesters.forEach { semester -&gt;&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;  - ${semester.displayName} (${semester.value}) [selected: ${semester.isSelected}]&quot;)&#10;        }&#10;&#10;        return semesters&#10;    }&#10;&#10;    /**&#10;     * Parses monthly/weekly schedule from HTML&#10;     */&#10;    fun parseSchedule(html: String): List&lt;TimetableDay&gt; {&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;=== PARSING SCHEDULE FROM HTML ===&quot;)&#10;&#10;        val document = Jsoup.parse(html)&#10;        val dateFormatter = DateTimeFormatter.ofPattern(&quot;dd.MM.yyyy&quot;)&#10;&#10;        val table = document.select(&quot;table.nb&quot;).first() ?: return emptyList()&#10;        val caption = table.select(&quot;caption&quot;).first()?.text()&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Table caption: $caption&quot;)&#10;&#10;        val dateRangeRegex = Regex(&quot;Stundenplan vom (\\d{2}\\.\\d{2}\\.) bis (\\d{2}\\.\\d{2}\\.)&quot;)&#10;        val matchResult = caption?.let { dateRangeRegex.find(it) }&#10;&#10;        val startDateString = matchResult?.groupValues?.get(1)&#10;        val endDateString = matchResult?.groupValues?.get(2)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Start date string: $startDateString, End date string: $endDateString&quot;)&#10;&#10;        val currentYear = java.time.LocalDate.now().year&#10;&#10;        val startLocalDate = requireNotNull(startDateString?.let {&#10;            java.time.LocalDate.parse(it + currentYear, dateFormatter)&#10;        }) {&#10;            &quot;Could not parse start date from caption: $caption&quot;&#10;        }&#10;        val endLocalDate = requireNotNull(endDateString?.let {&#10;            java.time.LocalDate.parse(it + currentYear, dateFormatter)&#10;        }) {&#10;            &quot;Could not parse end date from caption: $caption&quot;&#10;        }&#10;&#10;        // Find the header row with weekday columns&#10;        val headerRow = table.select(&quot;tr.tbsubhead&quot;).first() ?: return emptyList()&#10;        val dayToDateMap = mutableMapOf&lt;String, java.time.LocalDate&gt;()&#10;&#10;        // Parse dates from table headers directly - look for th.weekday elements with links&#10;        headerRow.select(&quot;th.weekday&quot;).forEach { dayHeaderElement -&gt;&#10;            val link = dayHeaderElement.select(&quot;a&quot;).first()&#10;            val headerText = link?.text()?.trim() ?: dayHeaderElement.text().trim()&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Processing header: '$headerText'&quot;)&#10;&#10;            // Extract day abbreviation and date from header text like &quot;Mo 30.06.&quot;&#10;            val headerPattern = Regex(&quot;(\\w+)\\s+(\\d{2}\\.\\d{2})\\.&quot;)&#10;            val headerMatch = headerPattern.find(headerText)&#10;&#10;            if (headerMatch != null) {&#10;                val dayAbbreviation = headerMatch.groupValues[1]&#10;                val dateString = headerMatch.groupValues[2] + &quot;.$currentYear&quot;&#10;&#10;                val fullDayName = when (dayAbbreviation) {&#10;                    &quot;Mo&quot; -&gt; &quot;Montag&quot;&#10;                    &quot;Di&quot; -&gt; &quot;Dienstag&quot;&#10;                    &quot;Mi&quot; -&gt; &quot;Mittwoch&quot;&#10;                    &quot;Do&quot; -&gt; &quot;Donnerstag&quot;&#10;                    &quot;Fr&quot; -&gt; &quot;Freitag&quot;&#10;                    &quot;Sa&quot; -&gt; &quot;Samstag&quot;&#10;                    &quot;So&quot; -&gt; &quot;Sonntag&quot;&#10;                    else -&gt; {&#10;                        Log.w(&quot;DualisHtmlParser&quot;, &quot;Unknown day abbreviation: $dayAbbreviation&quot;)&#10;                        &quot;&quot;&#10;                    }&#10;                }&#10;&#10;                if (fullDayName.isNotEmpty()) {&#10;                    try {&#10;                        val parsedDate = java.time.LocalDate.parse(dateString, dateFormatter)&#10;                        dayToDateMap[fullDayName] = parsedDate&#10;                        Log.d(&quot;DualisHtmlParser&quot;, &quot;Mapped $fullDayName to $parsedDate&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;DualisHtmlParser&quot;, &quot;Error parsing date: $dateString&quot;, e)&#10;                    }&#10;                }&#10;            } else {&#10;                Log.w(&quot;DualisHtmlParser&quot;, &quot;Could not parse header: '$headerText'&quot;)&#10;            }&#10;        }&#10;&#10;        // If no headers were found with the standard approach, try extracting directly from the range&#10;        if (dayToDateMap.isEmpty()) {&#10;            Log.w(&quot;DualisHtmlParser&quot;, &quot;No dates found in headers, trying to map from date range&quot;)&#10;&#10;            // Create date mapping based on the date range from caption&#10;            var currentDate = startLocalDate&#10;            val weekDays = listOf(&#10;                &quot;Montag&quot;, &quot;Dienstag&quot;, &quot;Mittwoch&quot;, &quot;Donnerstag&quot;, &quot;Freitag&quot;, &quot;Samstag&quot;, &quot;Sonntag&quot;&#10;            )&#10;&#10;            while (!currentDate.isAfter(endLocalDate)) {&#10;                val dayOfWeek = currentDate.dayOfWeek.value // 1 = Monday, 7 = Sunday&#10;                val dayName = weekDays[dayOfWeek - 1]&#10;                dayToDateMap[dayName] = currentDate&#10;                Log.d(&quot;DualisHtmlParser&quot;, &quot;Fallback mapped $dayName to $currentDate&quot;)&#10;                currentDate = currentDate.plusDays(1)&#10;            }&#10;        }&#10;&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Day To Date Map: $dayToDateMap&quot;)&#10;&#10;        val eventsByFullDate = mutableMapOf&lt;java.time.LocalDate, MutableList&lt;TimetableEvent&gt;&gt;()&#10;        var currentDay = startLocalDate&#10;        while (!currentDay.isAfter(endLocalDate)) {&#10;            eventsByFullDate[currentDay] = mutableListOf()&#10;            currentDay = currentDay.plusDays(1)&#10;        }&#10;&#10;        val allAppointmentCells = document.select(&quot;td.appointment&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Found ${allAppointmentCells.size} appointment cells&quot;)&#10;&#10;        // Parse events&#10;        for (cell in allAppointmentCells) {&#10;            val cellHtml = cell.html()&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Processing appointment cell HTML: $cellHtml&quot;)&#10;&#10;            // Extract event detail URL from links in the cell&#10;            val eventLink = cell.select(&quot;a&quot;).first()&#10;            var eventDetailUrl: String? = null&#10;&#10;            if (eventLink != null) {&#10;                val href = eventLink.attr(&quot;href&quot;)&#10;                if (href.isNotEmpty()) {&#10;                    eventDetailUrl = if (href.startsWith(&quot;/&quot;)) {&#10;                        &quot;https://dualis.dhbw.de$href&quot;&#10;                    } else if (href.startsWith(&quot;scripts/&quot;)) {&#10;                        &quot;https://dualis.dhbw.de/$href&quot;&#10;                    } else if (!href.startsWith(&quot;http&quot;)) {&#10;                        &quot;https://dualis.dhbw.de/scripts/$href&quot;&#10;                    } else {&#10;                        href&#10;                    }&#10;                    Log.d(&quot;DualisHtmlParser&quot;, &quot;Found event detail URL: $eventDetailUrl&quot;)&#10;                }&#10;            }&#10;&#10;            // Extract title - get text content excluding timePeriod span&#10;            val clonedCell = cell.clone()&#10;            clonedCell.select(&quot;span.timePeriod&quot;).remove()&#10;            clonedCell.select(&quot;br&quot;).remove()&#10;            // Remove HTML comments and clean up&#10;            var title = clonedCell.text().trim()&#10;&#10;            // Clean up title by removing trailing &quot;&gt;&quot; and any HTML artifacts&#10;            title = title.replace(Regex(&quot;&gt;\\s*$&quot;), &quot;&quot;).trim()&#10;&#10;            // Skip if title is empty&#10;            if (title.isEmpty()) {&#10;                Log.d(&quot;DualisHtmlParser&quot;, &quot;Skipping cell with empty title&quot;)&#10;                continue&#10;            }&#10;&#10;            // Extract time and room information&#10;            val timePeriodSpans = cell.select(&quot;span.timePeriod&quot;)&#10;            var timePeriodText = &quot;&quot;&#10;&#10;            // Combine text from all timePeriod spans&#10;            for (span in timePeriodSpans) {&#10;                val spanText = span.text().trim()&#10;                if (spanText.isNotEmpty()) {&#10;                    if (timePeriodText.isNotEmpty()) {&#10;                        timePeriodText += &quot; $spanText&quot;&#10;                      } else {&#10;                        timePeriodText = spanText&#10;                    }&#10;                }&#10;            }&#10;&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Time period text: '$timePeriodText'&quot;)&#10;&#10;            // Parse time period - it might be in format &quot;08:15 - 12:30 HOR-120&quot; or similar&#10;            val timeRoomParts = timePeriodText.split(&quot;\\s+&quot;.toRegex()).filter { it.isNotBlank() }&#10;&#10;            var startTime = &quot;&quot;&#10;            var endTime = &quot;&quot;&#10;            var room = &quot;&quot;&#10;&#10;            if (timeRoomParts.size &gt;= 3) {&#10;                startTime = timeRoomParts[0]&#10;                // Skip the &quot;-&quot; separator&#10;                endTime = timeRoomParts[2]&#10;                // Room might be in the remaining parts&#10;                if (timeRoomParts.size &gt; 3) {&#10;                    val rawRoom = timeRoomParts.drop(3).joinToString(&quot; &quot;)&#10;                    room = parseRooms(rawRoom)&#10;                }&#10;            }&#10;&#10;            val lecturer = &quot;&quot; // Will be filled from detailed information later&#10;&#10;            // Get the day from the abbr attribute&#10;            val abbrAttribute = cell.attr(&quot;abbr&quot;)&#10;            val dayOfWeekInGerman = abbrAttribute.split(&quot; &quot;)[0]&#10;&#10;            val eventDate = dayToDateMap[dayOfWeekInGerman]&#10;&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Processing cell:&quot;)&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;  Title: '$title'&quot;)&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;  Time Period Text: '$timePeriodText'&quot;)&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;  Time Room Parts: $timeRoomParts&quot;)&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;  Start Time: '$startTime', End Time: '$endTime', Room: '$room'&quot;)&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;  Abbr Attribute: '$abbrAttribute', Day in German: '$dayOfWeekInGerman'&quot;)&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;  Event Date: $eventDate&quot;)&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;  Event Detail URL: $eventDetailUrl&quot;)&#10;&#10;            if (eventDate != null &amp;&amp; title.isNotEmpty()) {&#10;                // Create event object with basic information&#10;                val event = TimetableEvent(&#10;                    title = title,&#10;                    startTime = startTime,&#10;                    endTime = endTime,&#10;                    room = room,&#10;                    lecturer = lecturer,&#10;                    detailUrl = eventDetailUrl&#10;                )&#10;&#10;                eventsByFullDate[eventDate]?.add(event)&#10;                Log.d(&quot;DualisHtmlParser&quot;, &quot;Added event to date $eventDate: $title&quot;)&#10;            } else {&#10;                Log.w(&quot;DualisHtmlParser&quot;, &quot;Skipping event - eventDate: $eventDate, title: '$title'&quot;)&#10;            }&#10;        }&#10;&#10;        val sortedTimetableDays = eventsByFullDate.entries.sortedBy { it.key }.map { entry -&gt;&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Creating TimetableDay for ${dateFormatter.format(entry.key)} with ${entry.value.size} events&quot;)&#10;            TimetableDay(dateFormatter.format(entry.key), entry.value)&#10;        }&#10;&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Parsed ${sortedTimetableDays.size} timetable days&quot;)&#10;        sortedTimetableDays.forEach { day -&gt;&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Day ${day.date}: ${day.events.size} events&quot;)&#10;            day.events.forEach { event -&gt;&#10;                Log.d(&quot;DualisHtmlParser&quot;, &quot;  Event: ${event.title} (${event.startTime} - ${event.endTime}) in ${event.room}&quot;)&#10;            }&#10;        }&#10;&#10;        return sortedTimetableDays&#10;    }&#10;&#10;    /**&#10;     * Checks if the page is a redirect page&#10;     */&#10;    fun isRedirectPage(html: String): Boolean {&#10;        val document = Jsoup.parse(html)&#10;        return document.select(&quot;div#sessionId&quot;).first() != null&#10;    }&#10;&#10;    /**&#10;     * Extracts redirect URL from HTML page&#10;     */&#10;    fun extractRedirectUrl(html: String, baseUrl: String): String? {&#10;        val document = Jsoup.parse(html)&#10;        var nextRedirectUrl: String? = null&#10;&#10;        // Try to get from script first&#10;        for (element in document.select(&quot;script&quot;)) {&#10;            val content = element.html()&#10;            if (content.contains(&quot;window.location.href&quot;)) {&#10;                val regex = Regex(&quot;window\\.location\\.href\\s*=\\s*['\&quot;]([^'\&quot;]+)['\&quot;]&quot;)&#10;                val match = regex.find(content)&#10;                val relativeUrl = match?.groupValues?.get(1)&#10;                if (relativeUrl != null) {&#10;                    nextRedirectUrl = makeAbsoluteUrl(baseUrl, relativeUrl)&#10;                    break&#10;                }&#10;            }&#10;        }&#10;&#10;        // If not found in script, try from the &lt;a&gt; tag&#10;        if (nextRedirectUrl == null) {&#10;            val anchorElement = document.select(&quot;h2 a[href]&quot;).first()&#10;            val relativeUrl = anchorElement?.attr(&quot;href&quot;)&#10;            if (relativeUrl != null) {&#10;                nextRedirectUrl = makeAbsoluteUrl(baseUrl, relativeUrl)&#10;            }&#10;        }&#10;&#10;        return nextRedirectUrl&#10;    }&#10;&#10;    /**&#10;     * Parses notifications from the notifications archive HTML page&#10;     */&#10;    fun parseNotifications(html: String): NotificationList {&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;=== PARSING NOTIFICATIONS FROM HTML ===&quot;)&#10;&#10;        val document = Jsoup.parse(html)&#10;        val notifications = mutableListOf&lt;Notification&gt;()&#10;&#10;        // Find the main notifications table&#10;        val notificationTable = document.select(&quot;table.nb.rw-table.rw-all&quot;).first()&#10;&#10;        if (notificationTable == null) {&#10;            Log.w(&quot;DualisHtmlParser&quot;, &quot;No notification table found&quot;)&#10;            return NotificationList(emptyList(), 0)&#10;        }&#10;&#10;        // Parse all notification rows (skip header row)&#10;        val notificationRows = notificationTable.select(&quot;tr.tbdata&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Found ${notificationRows.size} notification rows&quot;)&#10;&#10;        notificationRows.forEachIndexed { index, row -&gt;&#10;            try {&#10;                val notification = parseNotificationRow(row, index)&#10;                if (notification != null) {&#10;                    notifications.add(notification)&#10;                    Log.d(&quot;DualisHtmlParser&quot;, &quot;Parsed notification: ${notification.subject}&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;DualisHtmlParser&quot;, &quot;Error parsing notification row $index&quot;, e)&#10;            }&#10;        }&#10;&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Successfully parsed ${notifications.size} notifications&quot;)&#10;        return NotificationList(notifications, notifications.size)&#10;    }&#10;&#10;    /**&#10;     * Parses a single notification row from the table&#10;     */&#10;    private fun parseNotificationRow(row: org.jsoup.nodes.Element, index: Int): Notification? {&#10;        val cells = row.select(&quot;td&quot;)&#10;&#10;        if (cells.size &lt; 6) {&#10;            Log.w(&quot;DualisHtmlParser&quot;, &quot;Notification row $index has insufficient cells: ${cells.size}&quot;)&#10;            return null&#10;        }&#10;&#10;        // Extract notification type from the icon&#10;        val iconCell = cells[0]&#10;        val iconImg = iconCell.select(&quot;img&quot;).first()&#10;        val isUnread = iconImg?.attr(&quot;src&quot;)?.contains(&quot;in_new.gif&quot;) == true&#10;&#10;        // Extract date and time&#10;        val date = cells[1].text().trim()&#10;        val time = cells[2].text().trim()&#10;&#10;        // Extract sender&#10;        val sender = cells[3].text().trim()&#10;&#10;        // Extract subject and detail URL&#10;        val subjectCell = cells[4]&#10;        val subjectLink = subjectCell.select(&quot;a&quot;).first()&#10;        val subject = subjectLink?.text()?.trim() ?: subjectCell.text().trim()&#10;&#10;        val detailUrl = subjectLink?.attr(&quot;href&quot;)?.let { href -&gt;&#10;            if (href.startsWith(&quot;/&quot;)) {&#10;                &quot;https://dualis.dhbw.de$href&quot;&#10;            } else if (!href.startsWith(&quot;http&quot;)) {&#10;                &quot;https://dualis.dhbw.de/$href&quot;&#10;            } else {&#10;                href&#10;            }&#10;        }&#10;&#10;        // Extract delete URL&#10;        val deleteCell = cells[5]&#10;        val deleteLink = deleteCell.select(&quot;a&quot;).first()&#10;        val deleteUrl = deleteLink?.attr(&quot;href&quot;)?.let { href -&gt;&#10;            if (href.startsWith(&quot;/&quot;)) {&#10;                &quot;https://dualis.dhbw.de$href&quot;&#10;            } else if (!href.startsWith(&quot;http&quot;)) {&#10;                &quot;https://dualis.dhbw.de/$href&quot;&#10;            } else {&#10;                href&#10;            }&#10;        }&#10;&#10;        // Determine notification type based on subject content&#10;        val notificationType = determineNotificationType(subject)&#10;&#10;        // Generate a unique ID for the notification&#10;        val notificationId = generateNotificationId(date, time, sender, subject)&#10;&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Parsed notification row:&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;  ID: $notificationId&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;  Date: $date, Time: $time&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;  Sender: $sender&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;  Subject: $subject&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;  Type: $notificationType&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;  Unread: $isUnread&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;  Detail URL: $detailUrl&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;  Delete URL: $deleteUrl&quot;)&#10;&#10;        return Notification(&#10;            id = notificationId,&#10;            date = date,&#10;            time = time,&#10;            sender = sender,&#10;            subject = subject,&#10;            type = notificationType,&#10;            isUnread = isUnread,&#10;            detailUrl = detailUrl,&#10;            deleteUrl = deleteUrl&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Determines the notification type based on the subject content&#10;     */&#10;    private fun determineNotificationType(subject: String): NotificationType {&#10;        return when {&#10;            subject.contains(&quot;Termin geändert&quot;, ignoreCase = true) -&gt; NotificationType.SCHEDULE_CHANGE&#10;            subject.contains(&quot;Termin festgelegt&quot;, ignoreCase = true) -&gt; NotificationType.SCHEDULE_SET&#10;            subject.contains(&quot;schedule&quot;, ignoreCase = true) -&gt; NotificationType.SCHEDULE_CHANGE&#10;            subject.contains(&quot;appointment&quot;, ignoreCase = true) -&gt; NotificationType.SCHEDULE_CHANGE&#10;            else -&gt; NotificationType.GENERAL_MESSAGE&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generates a unique ID for a notification based on its properties&#10;     */&#10;    private fun generateNotificationId(date: String, time: String, sender: String, subject: String): String {&#10;        val combined = &quot;$date-$time-$sender-$subject&quot;&#10;        return combined.hashCode().toString()&#10;    }&#10;&#10;" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.data.dualis.network&#10;&#10;import android.util.Log&#10;import de.fampopprol.dhbwhorb.data.dualis.models.DualisUrl&#10;import de.fampopprol.dhbwhorb.data.dualis.models.Semester&#10;import de.fampopprol.dhbwhorb.data.dualis.models.TimetableDay&#10;import de.fampopprol.dhbwhorb.data.dualis.models.TimetableEvent&#10;import de.fampopprol.dhbwhorb.data.dualis.models.Notification&#10;import de.fampopprol.dhbwhorb.data.dualis.models.NotificationType&#10;import de.fampopprol.dhbwhorb.data.dualis.models.NotificationList&#10;import org.jsoup.Jsoup&#10;import java.time.format.DateTimeFormatter&#10;&#10;/**&#10; * Handles HTML parsing operations for Dualis responses&#10; */&#10;class DualisHtmlParser {&#10;&#10;    /**&#10;     * Parses the main page to extract Dualis URLs&#10;     */&#10;    fun parseMainPage(html: String, authToken: String?): DualisUrl {&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;=== PARSING REAL MAIN PAGE ===&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;HTML length: ${html.length}&quot;)&#10;&#10;        val document = Jsoup.parse(html)&#10;        val dualisUrls = DualisUrl()&#10;        val dualisEndpoint = &quot;https://dualis.dhbw.de&quot;&#10;&#10;        // Log all links for debugging&#10;        val allLinks = document.select(&quot;a&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Found ${allLinks.size} total links in main page&quot;)&#10;&#10;        // Construct the COURSERESULTS URL using the auth token&#10;        if (authToken != null) {&#10;            val baseUrl = &quot;https://dualis.dhbw.de/scripts/mgrqispi.dll?APPNAME=CampusNet&amp;PRGNAME=COURSERESULTS&amp;ARGUMENTS=-N$authToken,-N000307,&quot;&#10;            dualisUrls.studentResultsUrl = baseUrl&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Constructed student results URL: ${dualisUrls.studentResultsUrl}&quot;)&#10;        }&#10;&#10;        // Extract course result URL&#10;        val courseResultElement = document.select(&quot;a:contains(Prüfungsergebnisse)&quot;).first()&#10;        if (courseResultElement != null) {&#10;            val rawHref = courseResultElement.attr(&quot;href&quot;)&#10;            dualisUrls.courseResultUrl = if (rawHref.startsWith(&quot;/&quot;)) dualisEndpoint + rawHref else rawHref&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Found course results URL: ${dualisUrls.courseResultUrl}&quot;)&#10;        }&#10;&#10;        // Extract monthly schedule URL&#10;        val monthlyScheduleElement = document.select(&quot;a:contains(diese Woche)&quot;).first()&#10;        if (monthlyScheduleElement != null) {&#10;            val rawHref = monthlyScheduleElement.attr(&quot;href&quot;)&#10;            dualisUrls.monthlyScheduleUrl = if (rawHref.startsWith(&quot;/&quot;)) dualisEndpoint + rawHref else rawHref&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Found schedule URL: ${dualisUrls.monthlyScheduleUrl}&quot;)&#10;        }&#10;&#10;        // Extract logout URL&#10;        val logoutElement = document.select(&quot;a:contains(Abmelden)&quot;).first()&#10;        if (logoutElement != null) {&#10;            val rawHref = logoutElement.attr(&quot;href&quot;)&#10;            dualisUrls.logoutUrl = if (rawHref.startsWith(&quot;/&quot;)) dualisEndpoint + rawHref else rawHref&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Found logout URL: ${dualisUrls.logoutUrl}&quot;)&#10;        }&#10;&#10;        // Extract notifications URL - look for &quot;Nachrichten&quot; link&#10;        val notificationsElement = document.select(&quot;a:contains(Nachrichten)&quot;).first()&#10;        if (notificationsElement != null) {&#10;            val rawHref = notificationsElement.attr(&quot;href&quot;)&#10;            dualisUrls.notificationsUrl = if (rawHref.startsWith(&quot;/&quot;)) dualisEndpoint + rawHref else rawHref&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Found notifications URL: ${dualisUrls.notificationsUrl}&quot;)&#10;        }&#10;&#10;        return dualisUrls&#10;    }&#10;&#10;    /**&#10;     * Checks if the HTML content represents the main page&#10;     */&#10;    fun isMainPage(html: String): Boolean {&#10;        val document = Jsoup.parse(html)&#10;        // Check for elements that are typically present on the main page&#10;        return document.select(&quot;a:contains(Prüfungsergebnisse)&quot;).isNotEmpty() ||&#10;               document.select(&quot;a:contains(diese Woche)&quot;).isNotEmpty() ||&#10;               document.select(&quot;a:contains(Abmelden)&quot;).isNotEmpty()&#10;    }&#10;&#10;    /**&#10;     * Checks if the response indicates an invalid token&#10;     */&#10;    fun isTokenInvalidResponse(html: String): Boolean {&#10;        return html.contains(&quot;Session ist abgelaufen&quot;) ||&#10;               html.contains(&quot;Session expired&quot;) ||&#10;               html.contains(&quot;Anmeldung erforderlich&quot;) ||&#10;               html.contains(&quot;Login required&quot;) ||&#10;               html.contains(&quot;LOGINCHECK&quot;)&#10;    }&#10;&#10;    /**&#10;     * Parses semester information from HTML&#10;     */&#10;    fun parseSemestersFromHtml(html: String): List&lt;Semester&gt; {&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;=== PARSING SEMESTERS FROM HTML ===&quot;)&#10;&#10;        val document = Jsoup.parse(html)&#10;        val semesters = mutableListOf&lt;Semester&gt;()&#10;&#10;        // Look for semester select dropdown&#10;        val semesterSelect = document.select(&quot;select#semester&quot;).first()&#10;&#10;        if (semesterSelect != null) {&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Found semester select dropdown&quot;)&#10;&#10;            val options = semesterSelect.select(&quot;option&quot;)&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Found ${options.size} semester options&quot;)&#10;            val semesterOptions = mutableListOf&lt;Triple&lt;String, String, Boolean&gt;&gt;()&#10;&#10;            options.forEach { option -&gt;&#10;                val value = option.attr(&quot;value&quot;)&#10;                val displayName = option.text().trim()&#10;                val isSelected = option.hasAttr(&quot;selected&quot;)&#10;&#10;                if (value.isNotEmpty() &amp;&amp; displayName.isNotEmpty()) {&#10;                    semesterOptions.add(Triple(value, displayName, isSelected))&#10;                    Log.d(&quot;DualisHtmlParser&quot;, &quot;Found semester option: $displayName (value: $value, selected: $isSelected)&quot;)&#10;                }&#10;            }&#10;&#10;            // Use the new factory method to create semesters from Dualis data&#10;            if (semesterOptions.isNotEmpty()) {&#10;                val dynamicSemesters = Semester.fromDualisOptions(semesterOptions)&#10;                semesters.addAll(dynamicSemesters)&#10;                Log.d(&quot;DualisHtmlParser&quot;, &quot;Created ${dynamicSemesters.size} semesters from Dualis data&quot;)&#10;            } else {&#10;                Log.w(&quot;DualisHtmlParser&quot;, &quot;No valid semester options found, using defaults&quot;)&#10;                semesters.addAll(Semester.getDefaultSemesters())&#10;            }&#10;        } else {&#10;            Log.w(&quot;DualisHtmlParser&quot;, &quot;No semester select dropdown found, using defaults&quot;)&#10;            semesters.addAll(Semester.getDefaultSemesters())&#10;        }&#10;&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Final semester list:&quot;)&#10;        semesters.forEach { semester -&gt;&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;  - ${semester.displayName} (${semester.value}) [selected: ${semester.isSelected}]&quot;)&#10;        }&#10;&#10;        return semesters&#10;    }&#10;&#10;    /**&#10;     * Parses monthly/weekly schedule from HTML&#10;     */&#10;    fun parseSchedule(html: String): List&lt;TimetableDay&gt; {&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;=== PARSING SCHEDULE FROM HTML ===&quot;)&#10;&#10;        val document = Jsoup.parse(html)&#10;        val dateFormatter = DateTimeFormatter.ofPattern(&quot;dd.MM.yyyy&quot;)&#10;&#10;        val table = document.select(&quot;table.nb&quot;).first() ?: return emptyList()&#10;        val caption = table.select(&quot;caption&quot;).first()?.text()&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Table caption: $caption&quot;)&#10;&#10;        val dateRangeRegex = Regex(&quot;Stundenplan vom (\\d{2}\\.\\d{2}\\.) bis (\\d{2}\\.\\d{2}\\.)&quot;)&#10;        val matchResult = caption?.let { dateRangeRegex.find(it) }&#10;&#10;        val startDateString = matchResult?.groupValues?.get(1)&#10;        val endDateString = matchResult?.groupValues?.get(2)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Start date string: $startDateString, End date string: $endDateString&quot;)&#10;&#10;        val currentYear = java.time.LocalDate.now().year&#10;&#10;        val startLocalDate = requireNotNull(startDateString?.let {&#10;            java.time.LocalDate.parse(it + currentYear, dateFormatter)&#10;        }) {&#10;            &quot;Could not parse start date from caption: $caption&quot;&#10;        }&#10;        val endLocalDate = requireNotNull(endDateString?.let {&#10;            java.time.LocalDate.parse(it + currentYear, dateFormatter)&#10;        }) {&#10;            &quot;Could not parse end date from caption: $caption&quot;&#10;        }&#10;&#10;        // Find the header row with weekday columns&#10;        val headerRow = table.select(&quot;tr.tbsubhead&quot;).first() ?: return emptyList()&#10;        val dayToDateMap = mutableMapOf&lt;String, java.time.LocalDate&gt;()&#10;&#10;        // Parse dates from table headers directly - look for th.weekday elements with links&#10;        headerRow.select(&quot;th.weekday&quot;).forEach { dayHeaderElement -&gt;&#10;            val link = dayHeaderElement.select(&quot;a&quot;).first()&#10;            val headerText = link?.text()?.trim() ?: dayHeaderElement.text().trim()&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Processing header: '$headerText'&quot;)&#10;&#10;            // Extract day abbreviation and date from header text like &quot;Mo 30.06.&quot;&#10;            val headerPattern = Regex(&quot;(\\w+)\\s+(\\d{2}\\.\\d{2})\\.&quot;)&#10;            val headerMatch = headerPattern.find(headerText)&#10;&#10;            if (headerMatch != null) {&#10;                val dayAbbreviation = headerMatch.groupValues[1]&#10;                val dateString = headerMatch.groupValues[2] + &quot;.$currentYear&quot;&#10;&#10;                val fullDayName = when (dayAbbreviation) {&#10;                    &quot;Mo&quot; -&gt; &quot;Montag&quot;&#10;                    &quot;Di&quot; -&gt; &quot;Dienstag&quot;&#10;                    &quot;Mi&quot; -&gt; &quot;Mittwoch&quot;&#10;                    &quot;Do&quot; -&gt; &quot;Donnerstag&quot;&#10;                    &quot;Fr&quot; -&gt; &quot;Freitag&quot;&#10;                    &quot;Sa&quot; -&gt; &quot;Samstag&quot;&#10;                    &quot;So&quot; -&gt; &quot;Sonntag&quot;&#10;                    else -&gt; {&#10;                        Log.w(&quot;DualisHtmlParser&quot;, &quot;Unknown day abbreviation: $dayAbbreviation&quot;)&#10;                        &quot;&quot;&#10;                    }&#10;                }&#10;&#10;                if (fullDayName.isNotEmpty()) {&#10;                    try {&#10;                        val parsedDate = java.time.LocalDate.parse(dateString, dateFormatter)&#10;                        dayToDateMap[fullDayName] = parsedDate&#10;                        Log.d(&quot;DualisHtmlParser&quot;, &quot;Mapped $fullDayName to $parsedDate&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;DualisHtmlParser&quot;, &quot;Error parsing date: $dateString&quot;, e)&#10;                    }&#10;                }&#10;            } else {&#10;                Log.w(&quot;DualisHtmlParser&quot;, &quot;Could not parse header: '$headerText'&quot;)&#10;            }&#10;        }&#10;&#10;        // If no headers were found with the standard approach, try extracting directly from the range&#10;        if (dayToDateMap.isEmpty()) {&#10;            Log.w(&quot;DualisHtmlParser&quot;, &quot;No dates found in headers, trying to map from date range&quot;)&#10;&#10;            // Create date mapping based on the date range from caption&#10;            var currentDate = startLocalDate&#10;            val weekDays = listOf(&#10;                &quot;Montag&quot;, &quot;Dienstag&quot;, &quot;Mittwoch&quot;, &quot;Donnerstag&quot;, &quot;Freitag&quot;, &quot;Samstag&quot;, &quot;Sonntag&quot;&#10;            )&#10;&#10;            while (!currentDate.isAfter(endLocalDate)) {&#10;                val dayOfWeek = currentDate.dayOfWeek.value // 1 = Monday, 7 = Sunday&#10;                val dayName = weekDays[dayOfWeek - 1]&#10;                dayToDateMap[dayName] = currentDate&#10;                Log.d(&quot;DualisHtmlParser&quot;, &quot;Fallback mapped $dayName to $currentDate&quot;)&#10;                currentDate = currentDate.plusDays(1)&#10;            }&#10;        }&#10;&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Day To Date Map: $dayToDateMap&quot;)&#10;&#10;        val eventsByFullDate = mutableMapOf&lt;java.time.LocalDate, MutableList&lt;TimetableEvent&gt;&gt;()&#10;        var currentDay = startLocalDate&#10;        while (!currentDay.isAfter(endLocalDate)) {&#10;            eventsByFullDate[currentDay] = mutableListOf()&#10;            currentDay = currentDay.plusDays(1)&#10;        }&#10;&#10;        val allAppointmentCells = document.select(&quot;td.appointment&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Found ${allAppointmentCells.size} appointment cells&quot;)&#10;&#10;        // Parse events&#10;        for (cell in allAppointmentCells) {&#10;            val cellHtml = cell.html()&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Processing appointment cell HTML: $cellHtml&quot;)&#10;&#10;            // Extract event detail URL from links in the cell&#10;            val eventLink = cell.select(&quot;a&quot;).first()&#10;            var eventDetailUrl: String? = null&#10;&#10;            if (eventLink != null) {&#10;                val href = eventLink.attr(&quot;href&quot;)&#10;                if (href.isNotEmpty()) {&#10;                    eventDetailUrl = if (href.startsWith(&quot;/&quot;)) {&#10;                        &quot;https://dualis.dhbw.de$href&quot;&#10;                    } else if (href.startsWith(&quot;scripts/&quot;)) {&#10;                        &quot;https://dualis.dhbw.de/$href&quot;&#10;                    } else if (!href.startsWith(&quot;http&quot;)) {&#10;                        &quot;https://dualis.dhbw.de/scripts/$href&quot;&#10;                    } else {&#10;                        href&#10;                    }&#10;                    Log.d(&quot;DualisHtmlParser&quot;, &quot;Found event detail URL: $eventDetailUrl&quot;)&#10;                }&#10;            }&#10;&#10;            // Extract title - get text content excluding timePeriod span&#10;            val clonedCell = cell.clone()&#10;            clonedCell.select(&quot;span.timePeriod&quot;).remove()&#10;            clonedCell.select(&quot;br&quot;).remove()&#10;            // Remove HTML comments and clean up&#10;            var title = clonedCell.text().trim()&#10;&#10;            // Clean up title by removing trailing &quot;&gt;&quot; and any HTML artifacts&#10;            title = title.replace(Regex(&quot;&gt;\\s*$&quot;), &quot;&quot;).trim()&#10;&#10;            // Skip if title is empty&#10;            if (title.isEmpty()) {&#10;                Log.d(&quot;DualisHtmlParser&quot;, &quot;Skipping cell with empty title&quot;)&#10;                continue&#10;            }&#10;&#10;            // Extract time and room information&#10;            val timePeriodSpans = cell.select(&quot;span.timePeriod&quot;)&#10;            var timePeriodText = &quot;&quot;&#10;&#10;            // Combine text from all timePeriod spans&#10;            for (span in timePeriodSpans) {&#10;                val spanText = span.text().trim()&#10;                if (spanText.isNotEmpty()) {&#10;                    if (timePeriodText.isNotEmpty()) {&#10;                        timePeriodText += &quot; $spanText&quot;&#10;                      } else {&#10;                        timePeriodText = spanText&#10;                    }&#10;                }&#10;            }&#10;&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Time period text: '$timePeriodText'&quot;)&#10;&#10;            // Parse time period - it might be in format &quot;08:15 - 12:30 HOR-120&quot; or similar&#10;            val timeRoomParts = timePeriodText.split(&quot;\\s+&quot;.toRegex()).filter { it.isNotBlank() }&#10;&#10;            var startTime = &quot;&quot;&#10;            var endTime = &quot;&quot;&#10;            var room = &quot;&quot;&#10;&#10;            if (timeRoomParts.size &gt;= 3) {&#10;                startTime = timeRoomParts[0]&#10;                // Skip the &quot;-&quot; separator&#10;                endTime = timeRoomParts[2]&#10;                // Room might be in the remaining parts&#10;                if (timeRoomParts.size &gt; 3) {&#10;                    val rawRoom = timeRoomParts.drop(3).joinToString(&quot; &quot;)&#10;                    room = parseRooms(rawRoom)&#10;                }&#10;            }&#10;&#10;            val lecturer = &quot;&quot; // Will be filled from detailed information later&#10;&#10;            // Get the day from the abbr attribute&#10;            val abbrAttribute = cell.attr(&quot;abbr&quot;)&#10;            val dayOfWeekInGerman = abbrAttribute.split(&quot; &quot;)[0]&#10;&#10;            val eventDate = dayToDateMap[dayOfWeekInGerman]&#10;&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Processing cell:&quot;)&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;  Title: '$title'&quot;)&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;  Time Period Text: '$timePeriodText'&quot;)&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;  Time Room Parts: $timeRoomParts&quot;)&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;  Start Time: '$startTime', End Time: '$endTime', Room: '$room'&quot;)&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;  Abbr Attribute: '$abbrAttribute', Day in German: '$dayOfWeekInGerman'&quot;)&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;  Event Date: $eventDate&quot;)&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;  Event Detail URL: $eventDetailUrl&quot;)&#10;&#10;            if (eventDate != null &amp;&amp; title.isNotEmpty()) {&#10;                // Create event object with basic information&#10;                val event = TimetableEvent(&#10;                    title = title,&#10;                    startTime = startTime,&#10;                    endTime = endTime,&#10;                    room = room,&#10;                    lecturer = lecturer,&#10;                    detailUrl = eventDetailUrl&#10;                )&#10;&#10;                eventsByFullDate[eventDate]?.add(event)&#10;                Log.d(&quot;DualisHtmlParser&quot;, &quot;Added event to date $eventDate: $title&quot;)&#10;            } else {&#10;                Log.w(&quot;DualisHtmlParser&quot;, &quot;Skipping event - eventDate: $eventDate, title: '$title'&quot;)&#10;            }&#10;        }&#10;&#10;        val sortedTimetableDays = eventsByFullDate.entries.sortedBy { it.key }.map { entry -&gt;&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Creating TimetableDay for ${dateFormatter.format(entry.key)} with ${entry.value.size} events&quot;)&#10;            TimetableDay(dateFormatter.format(entry.key), entry.value)&#10;        }&#10;&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Parsed ${sortedTimetableDays.size} timetable days&quot;)&#10;        sortedTimetableDays.forEach { day -&gt;&#10;            Log.d(&quot;DualisHtmlParser&quot;, &quot;Day ${day.date}: ${day.events.size} events&quot;)&#10;            day.events.forEach { event -&gt;&#10;                Log.d(&quot;DualisHtmlParser&quot;, &quot;  Event: ${event.title} (${event.startTime} - ${event.endTime}) in ${event.room}&quot;)&#10;            }&#10;        }&#10;&#10;        return sortedTimetableDays&#10;    }&#10;&#10;    /**&#10;     * Checks if the page is a redirect page&#10;     */&#10;    fun isRedirectPage(html: String): Boolean {&#10;        val document = Jsoup.parse(html)&#10;        return document.select(&quot;div#sessionId&quot;).first() != null&#10;    }&#10;&#10;    /**&#10;     * Extracts redirect URL from HTML page&#10;     */&#10;    fun extractRedirectUrl(html: String, baseUrl: String): String? {&#10;        val document = Jsoup.parse(html)&#10;        var nextRedirectUrl: String? = null&#10;&#10;        // Try to get from script first&#10;        for (element in document.select(&quot;script&quot;)) {&#10;            val content = element.html()&#10;            if (content.contains(&quot;window.location.href&quot;)) {&#10;                val regex = Regex(&quot;window\\.location\\.href\\s*=\\s*['\&quot;]([^'\&quot;]+)['\&quot;]&quot;)&#10;                val match = regex.find(content)&#10;                val relativeUrl = match?.groupValues?.get(1)&#10;                if (relativeUrl != null) {&#10;                    nextRedirectUrl = makeAbsoluteUrl(baseUrl, relativeUrl)&#10;                    break&#10;                }&#10;            }&#10;        }&#10;&#10;        // If not found in script, try from the &lt;a&gt; tag&#10;        if (nextRedirectUrl == null) {&#10;            val anchorElement = document.select(&quot;h2 a[href]&quot;).first()&#10;            val relativeUrl = anchorElement?.attr(&quot;href&quot;)&#10;            if (relativeUrl != null) {&#10;                nextRedirectUrl = makeAbsoluteUrl(baseUrl, relativeUrl)&#10;            }&#10;        }&#10;&#10;        return nextRedirectUrl&#10;    }&#10;&#10;    /**&#10;     * Parses notifications from the notifications archive HTML page&#10;     */&#10;    fun parseNotifications(html: String): NotificationList {&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;=== PARSING NOTIFICATIONS FROM HTML ===&quot;)&#10;&#10;        val document = Jsoup.parse(html)&#10;        val notifications = mutableListOf&lt;Notification&gt;()&#10;&#10;        // Find the main notifications table&#10;        val notificationTable = document.select(&quot;table.nb.rw-table.rw-all&quot;).first()&#10;&#10;        if (notificationTable == null) {&#10;            Log.w(&quot;DualisHtmlParser&quot;, &quot;No notification table found&quot;)&#10;            return NotificationList(emptyList(), 0)&#10;        }&#10;&#10;        // Parse all notification rows (skip header row)&#10;        val notificationRows = notificationTable.select(&quot;tr.tbdata&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Found ${notificationRows.size} notification rows&quot;)&#10;&#10;        notificationRows.forEachIndexed { index, row -&gt;&#10;            try {&#10;                val notification = parseNotificationRow(row, index)&#10;                if (notification != null) {&#10;                    notifications.add(notification)&#10;                    Log.d(&quot;DualisHtmlParser&quot;, &quot;Parsed notification: ${notification.subject}&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;DualisHtmlParser&quot;, &quot;Error parsing notification row $index&quot;, e)&#10;            }&#10;        }&#10;&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Successfully parsed ${notifications.size} notifications&quot;)&#10;        return NotificationList(notifications, notifications.size)&#10;    }&#10;&#10;    /**&#10;     * Parses a single notification row from the table&#10;     */&#10;    private fun parseNotificationRow(row: org.jsoup.nodes.Element, index: Int): Notification? {&#10;        val cells = row.select(&quot;td&quot;)&#10;&#10;        if (cells.size &lt; 6) {&#10;            Log.w(&quot;DualisHtmlParser&quot;, &quot;Notification row $index has insufficient cells: ${cells.size}&quot;)&#10;            return null&#10;        }&#10;&#10;        // Extract notification type from the icon&#10;        val iconCell = cells[0]&#10;        val iconImg = iconCell.select(&quot;img&quot;).first()&#10;        val isUnread = iconImg?.attr(&quot;src&quot;)?.contains(&quot;in_new.gif&quot;) == true&#10;&#10;        // Extract date and time&#10;        val date = cells[1].text().trim()&#10;        val time = cells[2].text().trim()&#10;&#10;        // Extract sender&#10;        val sender = cells[3].text().trim()&#10;&#10;        // Extract subject and detail URL&#10;        val subjectCell = cells[4]&#10;        val subjectLink = subjectCell.select(&quot;a&quot;).first()&#10;        val subject = subjectLink?.text()?.trim() ?: subjectCell.text().trim()&#10;&#10;        val detailUrl = subjectLink?.attr(&quot;href&quot;)?.let { href -&gt;&#10;            if (href.startsWith(&quot;/&quot;)) {&#10;                &quot;https://dualis.dhbw.de$href&quot;&#10;            } else if (!href.startsWith(&quot;http&quot;)) {&#10;                &quot;https://dualis.dhbw.de/$href&quot;&#10;            } else {&#10;                href&#10;            }&#10;        }&#10;&#10;        // Extract delete URL&#10;        val deleteCell = cells[5]&#10;        val deleteLink = deleteCell.select(&quot;a&quot;).first()&#10;        val deleteUrl = deleteLink?.attr(&quot;href&quot;)?.let { href -&gt;&#10;            if (href.startsWith(&quot;/&quot;)) {&#10;                &quot;https://dualis.dhbw.de$href&quot;&#10;            } else if (!href.startsWith(&quot;http&quot;)) {&#10;                &quot;https://dualis.dhbw.de/$href&quot;&#10;            } else {&#10;                href&#10;            }&#10;        }&#10;&#10;        // Determine notification type based on subject content&#10;        val notificationType = determineNotificationType(subject)&#10;&#10;        // Generate a unique ID for the notification&#10;        val notificationId = generateNotificationId(date, time, sender, subject)&#10;&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;Parsed notification row:&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;  ID: $notificationId&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;  Date: $date, Time: $time&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;  Sender: $sender&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;  Subject: $subject&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;  Type: $notificationType&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;  Unread: $isUnread&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;  Detail URL: $detailUrl&quot;)&#10;        Log.d(&quot;DualisHtmlParser&quot;, &quot;  Delete URL: $deleteUrl&quot;)&#10;&#10;        return Notification(&#10;            id = notificationId,&#10;            date = date,&#10;            time = time,&#10;            sender = sender,&#10;            subject = subject,&#10;            type = notificationType,&#10;            isUnread = isUnread,&#10;            detailUrl = detailUrl,&#10;            deleteUrl = deleteUrl&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Determines the notification type based on the subject content&#10;     */&#10;    private fun determineNotificationType(subject: String): NotificationType {&#10;        return when {&#10;            subject.contains(&quot;Termin geändert&quot;, ignoreCase = true) -&gt; NotificationType.SCHEDULE_CHANGE&#10;            subject.contains(&quot;Termin festgelegt&quot;, ignoreCase = true) -&gt; NotificationType.SCHEDULE_SET&#10;            subject.contains(&quot;schedule&quot;, ignoreCase = true) -&gt; NotificationType.SCHEDULE_CHANGE&#10;            subject.contains(&quot;appointment&quot;, ignoreCase = true) -&gt; NotificationType.SCHEDULE_CHANGE&#10;            else -&gt; NotificationType.GENERAL_MESSAGE&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generates a unique ID for a notification based on its properties&#10;     */&#10;    private fun generateNotificationId(date: String, time: String, sender: String, subject: String): String {&#10;        val combined = &quot;$date-$time-$sender-$subject&quot;&#10;        return combined.hashCode().toString()&#10;    }&#10;&#10;    /**&#10;     * Parses concatenated room strings like &quot;HOR-135HOR-136&quot; into separate rooms&#10;     * separated by commas like &quot;HOR-135, HOR-136&quot;&#10;     */&#10;    private fun parseRooms(roomString: String): String {&#10;        if (roomString.isEmpty()) return roomString&#10;&#10;        // Pattern to match room codes like HOR-135, A1.2.03, etc.&#10;        val roomPattern = Regex(&quot;([A-Z]+(?:\\d+)?[-.]\\d+(?:\\.\\d+)?)&quot;)&#10;&#10;        val matches = roomPattern.findAll(roomString)&#10;        val rooms = matches.map { it.value }.toList()&#10;&#10;        return if (rooms.size &gt; 1) {&#10;            rooms.joinToString(&quot;, &quot;)&#10;        } else {&#10;            roomString&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Utility method to make absolute URLs&#10;     */&#10;    private fun makeAbsoluteUrl(baseUrl: String, relativeUrl: String): String {&#10;        return try {&#10;            val base = java.net.URL(baseUrl)&#10;            java.net.URL(base, relativeUrl).toString()&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;DualisHtmlParser&quot;, &quot;Error making absolute URL: $e&quot;)&#10;            &quot;&quot;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/dualis/network/DualisService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/dualis/network/DualisService.kt" />
              <option name="originalContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.data.dualis.network&#10;&#10;import de.fampopprol.dhbwhorb.data.dualis.models.StudyGrades&#10;import de.fampopprol.dhbwhorb.data.dualis.models.TimetableDay&#10;import de.fampopprol.dhbwhorb.data.dualis.models.Semester&#10;import java.time.LocalDate&#10;&#10;/**&#10; * Main service class that coordinates between specialized Dualis services&#10; * This class now acts as a facade, delegating responsibilities to focused service classes&#10; */&#10;class DualisService {&#10;&#10;    // Core service components&#10;    private val networkClient = DualisNetworkClient()&#10;    private val urlManager = DualisUrlManager()&#10;    private val htmlParser = DualisHtmlParser()&#10;&#10;    // Specialized services&#10;    private val authService = DualisAuthenticationService(networkClient, urlManager, htmlParser)&#10;    private val scheduleService = DualisScheduleService(networkClient, urlManager, htmlParser, authService)&#10;    private val gradesService = DualisGradesService(networkClient, urlManager, htmlParser, authService)&#10;    /**&#10;     * Logs into Dualis with user credentials&#10;     */&#10;    fun login(user: String, pass: String, callback: (String?) -&gt; Unit) {&#10;        authService.login(user, pass, callback)&#10;    }&#10;&#10;    /**&#10;     * Gets monthly schedule for specified year and month&#10;     */&#10;    fun getMonthlySchedule(year: Int, month: Int, callback: (List&lt;TimetableDay&gt;?) -&gt; Unit) {&#10;        scheduleService.getMonthlySchedule(year, month, callback)&#10;    }&#10;&#10;    /**&#10;     * Gets weekly schedule for specified date&#10;     */&#10;    fun getWeeklySchedule(targetDate: LocalDate, callback: (List&lt;TimetableDay&gt;?) -&gt; Unit) {&#10;        scheduleService.getWeeklySchedule(targetDate, callback)&#10;    }&#10;&#10;    /**&#10;     * Gets available semesters&#10;     */&#10;    fun getAvailableSemesters(callback: (List&lt;Semester&gt;?) -&gt; Unit) {&#10;        gradesService.getAvailableSemesters(callback)&#10;    }&#10;&#10;    /**&#10;     * Gets study grades for a specific semester&#10;     */&#10;    fun getStudyGradesForSemester(semester: Semester, callback: (StudyGrades?) -&gt; Unit) {&#10;        gradesService.getStudyGradesForSemester(semester, callback)&#10;    }&#10;&#10;    /**&#10;     * Gets study grades with optional semester argument&#10;     */&#10;    fun getStudyGrades(semesterArgument: String = &quot;&quot;, callback: (StudyGrades?) -&gt; Unit) {&#10;        gradesService.getStudyGrades(semesterArgument, callback)&#10;    }&#10;    &#10;&#10;     * Logs out and clears all stored data&#10;     */&#10;    fun logout() {&#10;        authService.logout()&#10;    }&#10;&#10;    /**&#10;     * Re-authenticates if needed (mainly for internal use by other services)&#10;     */&#10;    fun reAuthenticateIfNeeded(callback: (Boolean) -&gt; Unit) {&#10;        authService.reAuthenticateIfNeeded(callback)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.data.dualis.network&#10;&#10;import de.fampopprol.dhbwhorb.data.dualis.models.StudyGrades&#10;import de.fampopprol.dhbwhorb.data.dualis.models.TimetableDay&#10;import de.fampopprol.dhbwhorb.data.dualis.models.Semester&#10;import java.time.LocalDate&#10;&#10;/**&#10; * Main service class that coordinates between specialized Dualis services&#10; * This class now acts as a facade, delegating responsibilities to focused service classes&#10; */&#10;class DualisService {&#10;&#10;    // Core service components&#10;    private val networkClient = DualisNetworkClient()&#10;    private val urlManager = DualisUrlManager()&#10;    private val htmlParser = DualisHtmlParser()&#10;&#10;    // Specialized services&#10;    private val authService = DualisAuthenticationService(networkClient, urlManager, htmlParser)&#10;    private val scheduleService = DualisScheduleService(networkClient, urlManager, htmlParser, authService)&#10;    private val gradesService = DualisGradesService(networkClient, urlManager, htmlParser, authService)&#10;    private val notificationsService = DualisNotificationsService(networkClient, urlManager, htmlParser, authService)&#10;&#10;    /**&#10;     * Logs into Dualis with user credentials&#10;     */&#10;    fun login(user: String, pass: String, callback: (String?) -&gt; Unit) {&#10;        authService.login(user, pass, callback)&#10;    }&#10;&#10;    /**&#10;     * Gets monthly schedule for specified year and month&#10;     */&#10;    fun getMonthlySchedule(year: Int, month: Int, callback: (List&lt;TimetableDay&gt;?) -&gt; Unit) {&#10;        scheduleService.getMonthlySchedule(year, month, callback)&#10;    }&#10;&#10;    /**&#10;     * Gets weekly schedule for specified date&#10;     */&#10;    fun getWeeklySchedule(targetDate: LocalDate, callback: (List&lt;TimetableDay&gt;?) -&gt; Unit) {&#10;        scheduleService.getWeeklySchedule(targetDate, callback)&#10;    }&#10;&#10;    /**&#10;     * Gets available semesters&#10;     */&#10;    fun getAvailableSemesters(callback: (List&lt;Semester&gt;?) -&gt; Unit) {&#10;        gradesService.getAvailableSemesters(callback)&#10;    }&#10;&#10;    /**&#10;     * Gets study grades for a specific semester&#10;     */&#10;    fun getStudyGradesForSemester(semester: Semester, callback: (StudyGrades?) -&gt; Unit) {&#10;        gradesService.getStudyGradesForSemester(semester, callback)&#10;    }&#10;&#10;    /**&#10;     * Gets study grades with optional semester argument&#10;     */&#10;    fun getStudyGrades(semesterArgument: String = &quot;&quot;, callback: (StudyGrades?) -&gt; Unit) {&#10;        gradesService.getStudyGrades(semesterArgument, callback)&#10;    }&#10;&#10;    /**&#10;     * Gets unread notifications from Dualis&#10;     */&#10;    fun getUnreadNotifications(callback: (de.fampopprol.dhbwhorb.data.dualis.models.NotificationList?) -&gt; Unit) {&#10;        notificationsService.getUnreadNotifications(callback)&#10;    }&#10;&#10;    /**&#10;     * Gets detailed content for a specific notification&#10;     */&#10;    fun getNotificationDetails(notification: de.fampopprol.dhbwhorb.data.dualis.models.Notification, callback: (String?) -&gt; Unit) {&#10;        notificationsService.getNotificationDetails(notification, callback)&#10;    }&#10;&#10;    /**&#10;     * Checks if user is currently authenticated&#10;     */&#10;    fun isAuthenticated(): Boolean {&#10;        return authService.isAuthenticated()&#10;    }&#10;&#10;    /**&#10;     * Checks if the service is running in demo mode&#10;     */&#10;    fun isDemoMode(): Boolean {&#10;        return authService.isDemoMode&#10;    }&#10;&#10;    /**&#10;     * Logs out and clears all stored data&#10;     */&#10;    fun logout() {&#10;        authService.logout()&#10;    }&#10;&#10;    /**&#10;     * Re-authenticates if needed (mainly for internal use by other services)&#10;     */&#10;    fun reAuthenticateIfNeeded(callback: (Boolean) -&gt; Unit) {&#10;        authService.reAuthenticateIfNeeded(callback)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/dualis/network/DualisUrlManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/dualis/network/DualisUrlManager.kt" />
              <option name="originalContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.data.dualis.network&#10;&#10;import android.util.Log&#10;import de.fampopprol.dhbwhorb.data.dualis.models.DualisUrl&#10;&#10;/**&#10; * Manages URL construction and token operations for Dualis&#10; */&#10;class DualisUrlManager {&#10;&#10;    private val tokenRegex = Regex(&quot;ARGUMENTS=-N([0-9]{15})&quot;)&#10;    private var authToken: String? = null&#10;    val dualisUrls: DualisUrl = DualisUrl()&#10;&#10;    /**&#10;     * Updates the auth token from a URL containing the token&#10;     */&#10;    fun updateAuthToken(urlWithNewToken: String) {&#10;        val tokenMatch = tokenRegex.find(urlWithNewToken)&#10;        if (tokenMatch != null) {&#10;            authToken = tokenMatch.groupValues[1]&#10;            Log.d(&quot;DualisUrlManager&quot;, &quot;Updated Auth Token: $authToken&quot;)&#10;        } else {&#10;            Log.e(&quot;DualisUrlManager&quot;, &quot;Auth token not found in URL: $urlWithNewToken&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fills a URL with the current auth token&#10;     */&#10;    fun fillUrlWithAuthToken(url: String): String {&#10;        val match = tokenRegex.find(url)&#10;        return if (match != null &amp;&amp; authToken != null) {&#10;            val newUrl = url.replaceRange(match.range.first, match.range.last, &quot;ARGUMENTS=-N$authToken&quot;)&#10;            Log.d(&quot;DualisUrlManager&quot;, &quot;Filled URL with Auth Token: $newUrl&quot;)&#10;            newUrl&#10;        } else {&#10;            Log.w(&quot;DualisUrlManager&quot;, &quot;Could not fill URL with auth token. URL: $url, AuthToken: $authToken&quot;)&#10;            url&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Gets the current auth token&#10;     */&#10;    fun getAuthToken(): String? = authToken&#10;&#10;    /**&#10;     * Checks if we have a valid auth token&#10;     */&#10;    fun hasValidToken(): Boolean = authToken != null&#10;&#10;    /**&#10;     * Constructs study grades URL with optional semester argument&#10;     */&#10;    fun buildStudyGradesUrl(semesterArgument: String = &quot;&quot;): String? {&#10;        return if (authToken != null) {&#10;            &quot;https://dualis.dhbw.de/scripts/mgrqispi.dll?APPNAME=CampusNet&amp;PRGNAME=COURSERESULTS&amp;ARGUMENTS=-N$authToken,-N000307$semesterArgument&quot;&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Constructs schedule URL with date parameter&#10;     */&#10;    fun buildScheduleUrl(baseUrl: String, formattedDate: String): String {&#10;        val argumentsRegex = Regex(&quot;ARGUMENTS=([^&amp;]+)&quot;)&#10;        val existingArgumentsMatch = argumentsRegex.find(baseUrl)&#10;        val existingArguments = existingArgumentsMatch?.groupValues?.get(1) ?: &quot;&quot;&#10;&#10;        val updatedArguments = existingArguments.replaceFirst(&quot;-A&quot;, &quot;-A$formattedDate&quot;)&#10;&#10;        return baseUrl.replace(existingArguments, updatedArguments).replace(&#10;            &quot;ARGUMENTS=-N${authToken ?: &quot;&quot;}&quot;, &quot;ARGUMENTS=-N${authToken ?: &quot;&quot;}&quot;&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Constructs semester fetch URL&#10;     */&#10;    fun buildSemesterUrl(): String? {&#10;        return if (authToken != null) {&#10;            &quot;https://dualis.dhbw.de/scripts/mgrqispi.dll?APPNAME=CampusNet&amp;PRGNAME=COURSERESULTS&amp;ARGUMENTS=-N$authToken,-N000307,&quot;&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.data.dualis.network&#10;&#10;import android.util.Log&#10;import de.fampopprol.dhbwhorb.data.dualis.models.DualisUrl&#10;&#10;/**&#10; * Manages URL construction and token operations for Dualis&#10; */&#10;class DualisUrlManager {&#10;&#10;    private val tokenRegex = Regex(&quot;ARGUMENTS=-N([0-9]{15})&quot;)&#10;    private var authToken: String? = null&#10;    val dualisUrls: DualisUrl = DualisUrl()&#10;&#10;    /**&#10;     * Updates the auth token from a URL containing the token&#10;     */&#10;    fun updateAuthToken(urlWithNewToken: String) {&#10;        val tokenMatch = tokenRegex.find(urlWithNewToken)&#10;        if (tokenMatch != null) {&#10;            authToken = tokenMatch.groupValues[1]&#10;            Log.d(&quot;DualisUrlManager&quot;, &quot;Updated Auth Token: $authToken&quot;)&#10;        } else {&#10;            Log.e(&quot;DualisUrlManager&quot;, &quot;Auth token not found in URL: $urlWithNewToken&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fills a URL with the current auth token&#10;     */&#10;    fun fillUrlWithAuthToken(url: String): String {&#10;        val match = tokenRegex.find(url)&#10;        return if (match != null &amp;&amp; authToken != null) {&#10;            val newUrl = url.replaceRange(match.range.first, match.range.last, &quot;ARGUMENTS=-N$authToken&quot;)&#10;            Log.d(&quot;DualisUrlManager&quot;, &quot;Filled URL with Auth Token: $newUrl&quot;)&#10;            newUrl&#10;        } else {&#10;            Log.w(&quot;DualisUrlManager&quot;, &quot;Could not fill URL with auth token. URL: $url, AuthToken: $authToken&quot;)&#10;            url&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Gets the current auth token&#10;     */&#10;    fun getAuthToken(): String? = authToken&#10;&#10;    /**&#10;     * Checks if we have a valid auth token&#10;     */&#10;    fun hasValidToken(): Boolean = authToken != null&#10;&#10;    /**&#10;     * Constructs study grades URL with optional semester argument&#10;     */&#10;    fun buildStudyGradesUrl(semesterArgument: String = &quot;&quot;): String? {&#10;        return if (authToken != null) {&#10;            &quot;https://dualis.dhbw.de/scripts/mgrqispi.dll?APPNAME=CampusNet&amp;PRGNAME=COURSERESULTS&amp;ARGUMENTS=-N$authToken,-N000307$semesterArgument&quot;&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Constructs schedule URL with date parameter&#10;     */&#10;    fun buildScheduleUrl(baseUrl: String, formattedDate: String): String {&#10;        val argumentsRegex = Regex(&quot;ARGUMENTS=([^&amp;]+)&quot;)&#10;        val existingArgumentsMatch = argumentsRegex.find(baseUrl)&#10;        val existingArguments = existingArgumentsMatch?.groupValues?.get(1) ?: &quot;&quot;&#10;&#10;        val updatedArguments = existingArguments.replaceFirst(&quot;-A&quot;, &quot;-A$formattedDate&quot;)&#10;&#10;        return baseUrl.replace(existingArguments, updatedArguments).replace(&#10;            &quot;ARGUMENTS=-N${authToken ?: &quot;&quot;}&quot;, &quot;ARGUMENTS=-N${authToken ?: &quot;&quot;}&quot;&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Constructs semester fetch URL&#10;     */&#10;    fun buildSemesterUrl(): String? {&#10;        return if (authToken != null) {&#10;            &quot;https://dualis.dhbw.de/scripts/mgrqispi.dll?APPNAME=CampusNet&amp;PRGNAME=COURSERESULTS&amp;ARGUMENTS=-N$authToken,-N000307,&quot;&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Constructs notifications URL for unread messages&#10;     */&#10;    fun buildNotificationsUrl(): String? {&#10;        return if (authToken != null) {&#10;            &quot;https://dualis.dhbw.de/scripts/mgrqispi.dll?APPNAME=CampusNet&amp;PRGNAME=ACTION&amp;ARGUMENTS=-N$authToken&quot;&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Clears all stored data&#10;     */&#10;    fun clear() {&#10;        authToken = null&#10;        dualisUrls.mainPageUrl = null&#10;        dualisUrls.logoutUrl = null&#10;        dualisUrls.studentResultsUrl = null&#10;        dualisUrls.courseResultUrl = null&#10;        dualisUrls.monthlyScheduleUrl = null&#10;        dualisUrls.notificationsUrl = null&#10;        dualisUrls.semesterCourseResultUrls.clear()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/notification/ScheduleChangeManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/notification/ScheduleChangeManager.kt" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.data.notification&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Manages the schedule change monitoring lifecycle based on user preferences and permissions&#10; */&#10;class ScheduleChangeManager(private val context: Context) {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ScheduleChangeManager&quot;&#10;    }&#10;&#10;    private val preferencesManager = NotificationPreferencesManager(context)&#10;    private val scheduler = ScheduleChangeScheduler(context)&#10;    private val permissionHelper = NotificationPermissionHelper(context)&#10;&#10;    /**&#10;     * Initializes the schedule change monitoring and sets up preference observation&#10;     */&#10;    fun initialize() {&#10;        Log.d(TAG, &quot;Initializing schedule change manager&quot;)&#10;&#10;        // Check current state and start if appropriate&#10;        evaluateAndUpdateScheduler()&#10;&#10;        // Observe preference changes&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            combine(&#10;                preferencesManager.notificationsEnabled,&#10;                preferencesManager.timetableNotificationsEnabled&#10;            ) { generalEnabled, timetableEnabled -&gt;&#10;                Pair(generalEnabled, timetableEnabled)&#10;            }.collect { (generalEnabled, timetableEnabled) -&gt;&#10;                Log.d(TAG, &quot;Preferences changed - General: $generalEnabled, Timetable: $timetableEnabled&quot;)&#10;                evaluateAndUpdateScheduler()&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Evaluates current conditions and starts/stops the scheduler accordingly&#10;     */&#10;    private fun evaluateAndUpdateScheduler() {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            val hasPermission = permissionHelper.hasNotificationPermission()&#10;            val generalEnabled = preferencesManager.getNotificationsEnabledBlocking()&#10;            val timetableEnabled = preferencesManager.getTimetableNotificationsEnabledBlocking()&#10;&#10;            val shouldBeRunning = hasPermission &amp;&amp; generalEnabled &amp;&amp; timetableEnabled&#10;            val isCurrentlyRunning = scheduler.isPeriodicCheckingEnabled()&#10;&#10;            Log.d(TAG, &quot;Evaluation - Permission: $hasPermission, General: $generalEnabled, Timetable: $timetableEnabled&quot;)&#10;            Log.d(TAG, &quot;Should be running: $shouldBeRunning, Currently running: $isCurrentlyRunning&quot;)&#10;&#10;            when {&#10;                shouldBeRunning &amp;&amp; !isCurrentlyRunning -&gt; {&#10;                    Log.d(TAG, &quot;Starting schedule change monitoring&quot;)&#10;                    scheduler.startPeriodicChecking()&#10;                }&#10;                !shouldBeRunning &amp;&amp; isCurrentlyRunning -&gt; {&#10;                    Log.d(TAG, &quot;Stopping schedule change monitoring&quot;)&#10;                    scheduler.stopPeriodicChecking()&#10;                }&#10;                else -&gt; {&#10;                    Log.d(TAG, &quot;No action needed for schedule monitoring&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Called when notification permission is granted to re-evaluate scheduler state&#10;     */&#10;    fun onPermissionGranted() {&#10;        Log.d(TAG, &quot;Notification permission granted, re-evaluating scheduler&quot;)&#10;        evaluateAndUpdateScheduler()&#10;    }&#10;&#10;    /**&#10;     * Called when notification permission is denied to stop scheduler&#10;     */&#10;    fun onPermissionDenied() {&#10;        Log.d(TAG, &quot;Notification permission denied, stopping scheduler&quot;)&#10;        scheduler.stopPeriodicChecking()&#10;    }&#10;&#10;    /**&#10;     * Triggers an immediate check if conditions are met&#10;     */&#10;    fun triggerImmediateCheck() {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            val hasPermission = permissionHelper.hasNotificationPermission()&#10;            val generalEnabled = preferencesManager.getNotificationsEnabledBlocking()&#10;            val timetableEnabled = preferencesManager.getTimetableNotificationsEnabledBlocking()&#10;&#10;            if (hasPermission &amp;&amp; generalEnabled &amp;&amp; timetableEnabled) {&#10;                Log.d(TAG, &quot;Triggering immediate schedule check&quot;)&#10;                scheduler.triggerImmediateCheck()&#10;            } else {&#10;                Log.d(TAG, &quot;Cannot trigger immediate check - conditions not met&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Gets the current status of the schedule monitoring&#10;     */&#10;    fun isMonitoringActive(): Boolean {&#10;        return scheduler.isPeriodicCheckingEnabled()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/notification/ScheduleChangeScheduler.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/notification/ScheduleChangeScheduler.kt" />
              <option name="originalContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.data.notification&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.work.*&#10;&#10;/**&#10; * Schedules periodic checks for schedule change notifications&#10; */&#10;class ScheduleChangeScheduler(private val context: Context) {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ScheduleChangeScheduler&quot;&#10;        private const val WORK_NAME = &quot;schedule_change_check&quot;&#10;        private const val CHECK_INTERVAL_HOURS = 1L&#10;    }&#10;&#10;    private val workManager = WorkManager.getInstance(context)&#10;&#10;     */&#10;    fun startPeriodicChecking() {&#10;        Log.d(TAG, &quot;Starting periodic schedule change checking (every $CHECK_INTERVAL_HOURS hour(s))&quot;)&#10;        val constraints = Constraints.Builder()&#10;            .setRequiredNetworkType(NetworkType.CONNECTED)&#10;        Log.d(TAG, &quot;Starting periodic schedule change checking (every $CHECK_INTERVAL_HOURS hour(s))&quot;)&#10;     */&#10;        val constraints = Constraints.Builder()&#10;            .setRequiredNetworkType(NetworkType.CONNECTED)&#10;            .setRequiresBatteryNotLow(true)&#10;            .build()&#10;&#10;        val periodicWorkRequest = PeriodicWorkRequestBuilder&lt;ScheduleChangeWorker&gt;(&#10;            CHECK_INTERVAL_HOURS, TimeUnit.HOURS&#10;        )&#10;            .setConstraints(constraints)&#10;            .setBackoffCriteria(&#10;                BackoffPolicy.LINEAR,&#10;                15, TimeUnit.MINUTES&#10;            )&#10;            .build()&#10;&#10;        workManager.enqueueUniquePeriodicWork(&#10;            WORK_NAME,&#10;            ExistingPeriodicWorkPolicy.KEEP,&#10;            periodicWorkRequest&#10;        )&#10;    }&#10;        Log.d(TAG, &quot;Periodic schedule change checking scheduled successfully&quot;)&#10;     * Checks if periodic checking is currently enabled&#10;     */&#10;    fun isPeriodicCheckingEnabled(): Boolean {&#10;        return try {&#10;            val workInfos = workManager.getWorkInfosForUniqueWork(WORK_NAME).get()&#10;            workInfos.any { workInfo -&gt;&#10;                workInfo.state == WorkInfo.State.ENQUEUED || workInfo.state == WorkInfo.State.RUNNING&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error checking periodic work status&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Gets the status of the last schedule change check&#10;     */&#10;    fun getLastCheckStatus(): WorkInfo.State? {&#10;        return try {&#10;            val workInfos = workManager.getWorkInfosForUniqueWork(WORK_NAME).get()&#10;            workInfos.lastOrNull()?.state&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting last check status&quot;, e)&#10;            null&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.data.notification&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.work.*&#10;import kotlinx.coroutines.runBlocking&#10;import java.util.concurrent.TimeUnit&#10;&#10;/**&#10; * Schedules periodic checks for schedule change notifications&#10; */&#10;class ScheduleChangeScheduler(private val context: Context) {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ScheduleChangeScheduler&quot;&#10;        private const val WORK_NAME = &quot;schedule_change_check&quot;&#10;        private const val CHECK_INTERVAL_HOURS = 1L&#10;    }&#10;&#10;    private val workManager = WorkManager.getInstance(context)&#10;    private val preferencesManager = NotificationPreferencesManager(context)&#10;    private val permissionHelper = NotificationPermissionHelper(context)&#10;&#10;    /**&#10;     * Starts periodic checking for schedule changes every hour&#10;     * Only starts if timetable notifications are enabled and permissions are granted&#10;     */&#10;    fun startPeriodicChecking() {&#10;        Log.d(TAG, &quot;Checking if periodic schedule change checking should be started&quot;)&#10;&#10;        // Check permissions first&#10;        if (!permissionHelper.hasNotificationPermission()) {&#10;            Log.w(TAG, &quot;Notification permission not granted, cannot start schedule checking&quot;)&#10;            return&#10;        }&#10;&#10;        // Check if notifications and timetable notifications are enabled&#10;        runBlocking {&#10;            val notificationsEnabled = preferencesManager.getNotificationsEnabledBlocking()&#10;            val timetableNotificationsEnabled = preferencesManager.getTimetableNotificationsEnabledBlocking()&#10;&#10;            if (!notificationsEnabled) {&#10;                Log.d(TAG, &quot;General notifications are disabled, not starting schedule checking&quot;)&#10;                return@runBlocking&#10;            }&#10;&#10;            if (!timetableNotificationsEnabled) {&#10;                Log.d(TAG, &quot;Timetable notifications are disabled, not starting schedule checking&quot;)&#10;                return@runBlocking&#10;            }&#10;&#10;            Log.d(TAG, &quot;Starting periodic schedule change checking (every $CHECK_INTERVAL_HOURS hour(s))&quot;)&#10;&#10;            val constraints = Constraints.Builder()&#10;                .setRequiredNetworkType(NetworkType.CONNECTED)&#10;                .setRequiresBatteryNotLow(true)&#10;                .build()&#10;&#10;            val periodicWorkRequest = PeriodicWorkRequestBuilder&lt;ScheduleChangeWorker&gt;(&#10;                CHECK_INTERVAL_HOURS, TimeUnit.HOURS&#10;            )&#10;                .setConstraints(constraints)&#10;                .setBackoffCriteria(&#10;                    BackoffPolicy.LINEAR,&#10;                    15, TimeUnit.MINUTES&#10;                )&#10;                .build()&#10;&#10;            workManager.enqueueUniquePeriodicWork(&#10;                WORK_NAME,&#10;                ExistingPeriodicWorkPolicy.KEEP,&#10;                periodicWorkRequest&#10;            )&#10;&#10;            Log.d(TAG, &quot;Periodic schedule change checking scheduled successfully&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Stops periodic checking for schedule changes&#10;     */&#10;    fun stopPeriodicChecking() {&#10;        Log.d(TAG, &quot;Stopping periodic schedule change checking&quot;)&#10;        workManager.cancelUniqueWork(WORK_NAME)&#10;    }&#10;&#10;    /**&#10;     * Triggers an immediate check for schedule changes&#10;     */&#10;    fun triggerImmediateCheck() {&#10;        Log.d(TAG, &quot;Triggering immediate schedule change check&quot;)&#10;&#10;        val constraints = Constraints.Builder()&#10;            .setRequiredNetworkType(NetworkType.CONNECTED)&#10;            .build()&#10;&#10;        val immediateWorkRequest = OneTimeWorkRequestBuilder&lt;ScheduleChangeWorker&gt;()&#10;            .setConstraints(constraints)&#10;            .build()&#10;&#10;        workManager.enqueue(immediateWorkRequest)&#10;    }&#10;&#10;    /**&#10;     * Checks if periodic checking is currently enabled&#10;     */&#10;    fun isPeriodicCheckingEnabled(): Boolean {&#10;        return try {&#10;            val workInfos = workManager.getWorkInfosForUniqueWork(WORK_NAME).get()&#10;            workInfos.any { workInfo -&gt;&#10;                workInfo.state == WorkInfo.State.ENQUEUED || workInfo.state == WorkInfo.State.RUNNING&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error checking periodic work status&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Gets the status of the last schedule change check&#10;     */&#10;    fun getLastCheckStatus(): WorkInfo.State? {&#10;        return try {&#10;            val workInfos = workManager.getWorkInfosForUniqueWork(WORK_NAME).get()&#10;            workInfos.lastOrNull()?.state&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting last check status&quot;, e)&#10;            null&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/notification/ScheduleChangeWorker.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/notification/ScheduleChangeWorker.kt" />
              <option name="originalContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.data.notification&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.util.Log&#10;import androidx.work.Worker&#10;import androidx.work.WorkerParameters&#10;import de.fampopprol.dhbwhorb.data.dualis.models.NotificationType&#10;import de.fampopprol.dhbwhorb.data.dualis.network.DualisService&#10;import kotlinx.coroutines.runBlocking&#10;import java.util.concurrent.CountDownLatch&#10;import java.util.concurrent.TimeUnit&#10;&#10;/**&#10; * Background worker that periodically checks for schedule change notifications from Dualis&#10; */&#10;class ScheduleChangeWorker(&#10;    context: Context,&#10;    workerParams: WorkerParameters&#10;) : Worker(context, workerParams) {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ScheduleChangeWorker&quot;&#10;        private const val PREFS_NAME = &quot;schedule_notifications&quot;&#10;        private const val KEY_LAST_NOTIFICATION_IDS = &quot;last_notification_ids&quot;&#10;        private const val KEY_LAST_CHECK_TIME = &quot;last_check_time&quot;&#10;        private const val WORK_TIMEOUT_SECONDS = 30L&#10;    }&#10;&#10;    private val dualisService = DualisService()&#10;    private val notificationManager = DHBWNotificationManager(applicationContext)&#10;    private val preferences: SharedPreferences =&#10;        applicationContext.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;        Log.d(TAG, &quot;=== STARTING SCHEDULE CHANGE CHECK ===&quot;)&#10;&#10;        // Check if user is authenticated&#10;        if (!dualisService.isAuthenticated()) {&#10;        // Check if user is authenticated&#10;        if (!dualisService.isAuthenticated()) {&#10;            Log.d(TAG, &quot;User not authenticated, skipping schedule change check&quot;)&#10;            return Result.success()&#10;        }&#10;                    Log.d(TAG, &quot;Received ${notificationList.totalUnreadCount} unread notifications&quot;)&#10;        return try {&#10;&#10;                    // Filter for schedule-related notifications&#10;                    val scheduleNotifications = notificationList.unreadNotifications.filter { notification -&gt;&#10;                        notification.type == NotificationType.SCHEDULE_CHANGE ||&#10;                        notification.type == NotificationType.SCHEDULE_SET&#10;                    }&#10;&#10;                    Log.d(TAG, &quot;Found ${scheduleNotifications.size} schedule-related notifications&quot;)&#10;&#10;                    if (scheduleNotifications.isNotEmpty()) {&#10;                        // Check if these are new notifications we haven't seen before&#10;                        val newNotifications = filterNewNotifications(scheduleNotifications)&#10;&#10;                        if (newNotifications.isNotEmpty()) {&#10;                            Log.d(TAG, &quot;Found ${newNotifications.size} new schedule notifications&quot;)&#10;&#10;                            // Show notification to user&#10;                            showScheduleChangeNotification(newNotifications)&#10;&#10;                            // Update our stored notification IDs&#10;                            updateStoredNotificationIds(scheduleNotifications)&#10;&#10;                            workerResult = Result.success()&#10;                        } else {&#10;                            Log.d(TAG, &quot;No new schedule notifications since last check&quot;)&#10;                            workerResult = Result.success()&#10;                        }&#10;                    } else {&#10;                        Log.d(TAG, &quot;No schedule-related notifications found&quot;)&#10;                        workerResult = Result.success()&#10;                    }&#10;                } else {&#10;                    Log.w(TAG, &quot;Failed to fetch notifications from Dualis&quot;)&#10;                    workerResult = Result.retry()&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error processing notifications&quot;, e)&#10;                workerResult = Result.failure()&#10;            } finally {&#10;                // Update last check time&#10;                preferences.edit()&#10;                    .putLong(KEY_LAST_CHECK_TIME, System.currentTimeMillis())&#10;                    .apply()&#10;&#10;                latch.countDown()&#10;            }&#10;        }&#10;&#10;        // Wait for the async operation to complete with timeout&#10;        val completed = latch.await(WORK_TIMEOUT_SECONDS, TimeUnit.SECONDS)&#10;&#10;        return if (completed) {&#10;            workerResult&#10;        } else {&#10;            Log.w(TAG, &quot;Notification fetch timed out&quot;)&#10;            Result.retry()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Filters out notifications we've already seen in previous checks&#10;     */&#10;    private fun filterNewNotifications(&#10;        notifications: List&lt;de.fampopprol.dhbwhorb.data.dualis.models.Notification&gt;&#10;    ): List&lt;de.fampopprol.dhbwhorb.data.dualis.models.Notification&gt; {&#10;        val lastNotificationIds = preferences.getStringSet(KEY_LAST_NOTIFICATION_IDS, emptySet()) ?: emptySet()&#10;&#10;        return notifications.filter { notification -&gt;&#10;            !lastNotificationIds.contains(notification.id)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Updates the stored notification IDs for future comparisons&#10;     */&#10;    private fun updateStoredNotificationIds(&#10;        notifications: List&lt;de.fampopprol.dhbwhorb.data.dualis.models.Notification&gt;&#10;    ) {&#10;        val notificationIds = notifications.map { it.id }.toSet()&#10;        preferences.edit()&#10;            .putStringSet(KEY_LAST_NOTIFICATION_IDS, notificationIds)&#10;            .apply()&#10;    }&#10;&#10;    /**&#10;     * Shows a notification to the user about schedule changes&#10;     */&#10;    private fun showScheduleChangeNotification(&#10;        notifications: List&lt;de.fampopprol.dhbwhorb.data.dualis.models.Notification&gt;&#10;    ) {&#10;        val changes = notifications.map { notification -&gt;&#10;            when (notification.type) {&#10;                NotificationType.SCHEDULE_CHANGE -&gt; {&#10;                    val courseName = extractCourseName(notification.subject)&#10;                    &quot;Schedule changed: $courseName&quot;&#10;                }&#10;                NotificationType.SCHEDULE_SET -&gt; {&#10;                    val courseName = extractCourseName(notification.subject)&#10;                    &quot;New appointment: $courseName&quot;&#10;                }&#10;                else -&gt; notification.subject&#10;            }&#10;        }&#10;&#10;        Log.d(TAG, &quot;Showing notification for changes: $changes&quot;)&#10;        notificationManager.showTimetableChangeNotification(changes)&#10;    }&#10;&#10;    /**&#10;     * Extracts the course name from the notification subject&#10;     * Example: &quot;T4INF2904.2 / C# und .NET HOR-TINF2024&quot;: Termin geändert&#10;     * Returns: &quot;C# und .NET&quot;&#10;     */&#10;    private fun extractCourseName(subject: String): String {&#10;        // Try to extract course name from the subject&#10;        val regex = Regex(&quot;\&quot;([^\&quot;]*?)\&quot;&quot;)&#10;        val match = regex.find(subject)&#10;&#10;        if (match != null) {&#10;            val fullCourseName = match.groupValues[1]&#10;            // Extract just the course name part (after the course code and /)&#10;            val parts = fullCourseName.split(&quot; / &quot;)&#10;            if (parts.size &gt;= 2) {&#10;                // Remove the course code and location info&#10;                val courseNamePart = parts[1].trim()&#10;                // Remove trailing location info like &quot;HOR-TINF2024&quot;&#10;                val cleanCourseName = courseNamePart.replace(Regex(&quot;\\s+[A-Z]+-[A-Z0-9]+$&quot;), &quot;&quot;)&#10;                return cleanCourseName.ifEmpty { courseNamePart }&#10;            }&#10;        }&#10;&#10;        // Fallback: return original subject&#10;        return subject&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.data.notification&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.util.Log&#10;import androidx.work.Worker&#10;import androidx.work.WorkerParameters&#10;import de.fampopprol.dhbwhorb.data.dualis.models.NotificationType&#10;import de.fampopprol.dhbwhorb.data.dualis.network.DualisService&#10;import kotlinx.coroutines.runBlocking&#10;import java.util.concurrent.CountDownLatch&#10;import java.util.concurrent.TimeUnit&#10;&#10;/**&#10; * Background worker that periodically checks for schedule change notifications from Dualis&#10; */&#10;class ScheduleChangeWorker(&#10;    context: Context,&#10;    workerParams: WorkerParameters&#10;) : Worker(context, workerParams) {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ScheduleChangeWorker&quot;&#10;        private const val PREFS_NAME = &quot;schedule_notifications&quot;&#10;        private const val KEY_LAST_NOTIFICATION_IDS = &quot;last_notification_ids&quot;&#10;        private const val KEY_LAST_CHECK_TIME = &quot;last_check_time&quot;&#10;        private const val WORK_TIMEOUT_SECONDS = 30L&#10;    }&#10;&#10;    private val dualisService = DualisService()&#10;    private val notificationManager = DHBWNotificationManager(applicationContext)&#10;    private val preferences: SharedPreferences =&#10;        applicationContext.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;    private val preferencesManager = NotificationPreferencesManager(applicationContext)&#10;    private val permissionHelper = NotificationPermissionHelper(applicationContext)&#10;&#10;    override fun doWork(): Result {&#10;        Log.d(TAG, &quot;=== STARTING SCHEDULE CHANGE CHECK ===&quot;)&#10;&#10;        // Check permissions first&#10;        if (!permissionHelper.hasNotificationPermission()) {&#10;            Log.d(TAG, &quot;Notification permission not granted, skipping check&quot;)&#10;            return Result.success()&#10;        }&#10;&#10;        // Check if notifications are enabled&#10;        return try {&#10;            val notificationsEnabled = runBlocking { preferencesManager.getNotificationsEnabledBlocking() }&#10;            val timetableNotificationsEnabled = runBlocking { preferencesManager.getTimetableNotificationsEnabledBlocking() }&#10;&#10;            if (!notificationsEnabled || !timetableNotificationsEnabled) {&#10;                Log.d(TAG, &quot;Timetable notifications are disabled, skipping check&quot;)&#10;                return Result.success()&#10;            }&#10;&#10;            // Check if user is authenticated&#10;            if (!dualisService.isAuthenticated()) {&#10;                Log.d(TAG, &quot;User not authenticated, skipping schedule change check&quot;)&#10;                return Result.success()&#10;            }&#10;&#10;            val result = checkForScheduleChangeNotifications()&#10;            Log.d(TAG, &quot;=== SCHEDULE CHANGE CHECK COMPLETED ===&quot;)&#10;            result&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during schedule change check&quot;, e)&#10;            Result.retry()&#10;        }&#10;    }&#10;&#10;    private fun checkForScheduleChangeNotifications(): Result {&#10;        val latch = CountDownLatch(1)&#10;        var workerResult = Result.success()&#10;&#10;        dualisService.getUnreadNotifications { notificationList -&gt;&#10;            try {&#10;                if (notificationList != null) {&#10;                    Log.d(TAG, &quot;Received ${notificationList.totalUnreadCount} unread notifications&quot;)&#10;&#10;                    // Filter for schedule-related notifications&#10;                    val scheduleNotifications = notificationList.unreadNotifications.filter { notification -&gt;&#10;                        notification.type == NotificationType.SCHEDULE_CHANGE ||&#10;                        notification.type == NotificationType.SCHEDULE_SET&#10;                    }&#10;&#10;                    Log.d(TAG, &quot;Found ${scheduleNotifications.size} schedule-related notifications&quot;)&#10;&#10;                    if (scheduleNotifications.isNotEmpty()) {&#10;                        // Check if these are new notifications we haven't seen before&#10;                        val newNotifications = filterNewNotifications(scheduleNotifications)&#10;&#10;                        if (newNotifications.isNotEmpty()) {&#10;                            Log.d(TAG, &quot;Found ${newNotifications.size} new schedule notifications&quot;)&#10;&#10;                            // Show notification to user&#10;                            showScheduleChangeNotification(newNotifications)&#10;&#10;                            // Update our stored notification IDs&#10;                            updateStoredNotificationIds(scheduleNotifications)&#10;&#10;                            workerResult = Result.success()&#10;                        } else {&#10;                            Log.d(TAG, &quot;No new schedule notifications since last check&quot;)&#10;                            workerResult = Result.success()&#10;                        }&#10;                    } else {&#10;                        Log.d(TAG, &quot;No schedule-related notifications found&quot;)&#10;                        workerResult = Result.success()&#10;                    }&#10;                } else {&#10;                    Log.w(TAG, &quot;Failed to fetch notifications from Dualis&quot;)&#10;                    workerResult = Result.retry()&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error processing notifications&quot;, e)&#10;                workerResult = Result.failure()&#10;            } finally {&#10;                // Update last check time&#10;                preferences.edit()&#10;                    .putLong(KEY_LAST_CHECK_TIME, System.currentTimeMillis())&#10;                    .apply()&#10;&#10;                latch.countDown()&#10;            }&#10;        }&#10;&#10;        // Wait for the async operation to complete with timeout&#10;        val completed = latch.await(WORK_TIMEOUT_SECONDS, TimeUnit.SECONDS)&#10;&#10;        return if (completed) {&#10;            workerResult&#10;        } else {&#10;            Log.w(TAG, &quot;Notification fetch timed out&quot;)&#10;            Result.retry()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Filters out notifications we've already seen in previous checks&#10;     */&#10;    private fun filterNewNotifications(&#10;        notifications: List&lt;de.fampopprol.dhbwhorb.data.dualis.models.Notification&gt;&#10;    ): List&lt;de.fampopprol.dhbwhorb.data.dualis.models.Notification&gt; {&#10;        val lastNotificationIds = preferences.getStringSet(KEY_LAST_NOTIFICATION_IDS, emptySet()) ?: emptySet()&#10;&#10;        return notifications.filter { notification -&gt;&#10;            !lastNotificationIds.contains(notification.id)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Updates the stored notification IDs for future comparisons&#10;     */&#10;    private fun updateStoredNotificationIds(&#10;        notifications: List&lt;de.fampopprol.dhbwhorb.data.dualis.models.Notification&gt;&#10;    ) {&#10;        val notificationIds = notifications.map { it.id }.toSet()&#10;        preferences.edit()&#10;            .putStringSet(KEY_LAST_NOTIFICATION_IDS, notificationIds)&#10;            .apply()&#10;    }&#10;&#10;    /**&#10;     * Shows a notification to the user about schedule changes&#10;     */&#10;    private fun showScheduleChangeNotification(&#10;        notifications: List&lt;de.fampopprol.dhbwhorb.data.dualis.models.Notification&gt;&#10;    ) {&#10;        val changes = notifications.map { notification -&gt;&#10;            when (notification.type) {&#10;                NotificationType.SCHEDULE_CHANGE -&gt; {&#10;                    val courseName = extractCourseName(notification.subject)&#10;                    &quot;Schedule changed: $courseName&quot;&#10;                }&#10;                NotificationType.SCHEDULE_SET -&gt; {&#10;                    val courseName = extractCourseName(notification.subject)&#10;                    &quot;New appointment: $courseName&quot;&#10;                }&#10;                else -&gt; notification.subject&#10;            }&#10;        }&#10;&#10;        Log.d(TAG, &quot;Showing notification for changes: $changes&quot;)&#10;        notificationManager.showTimetableChangeNotification(changes)&#10;    }&#10;&#10;    /**&#10;     * Extracts the course name from the notification subject&#10;     * Example: &quot;T4INF2904.2 / C# und .NET HOR-TINF2024&quot;: Termin geändert&#10;     * Returns: &quot;C# und .NET&quot;&#10;     */&#10;    private fun extractCourseName(subject: String): String {&#10;        // Try to extract course name from the subject&#10;        val regex = Regex(&quot;\&quot;([^\&quot;]*?)\&quot;&quot;)&#10;        val match = regex.find(subject)&#10;&#10;        if (match != null) {&#10;            val fullCourseName = match.groupValues[1]&#10;            // Extract just the course name part (after the course code and /)&#10;            val parts = fullCourseName.split(&quot; / &quot;)&#10;            if (parts.size &gt;= 2) {&#10;                // Remove the course code and location info&#10;                val courseNamePart = parts[1].trim()&#10;                // Remove trailing location info like &quot;HOR-TINF2024&quot;&#10;                val cleanCourseName = courseNamePart.replace(Regex(&quot;\\s+[A-Z]+-[A-Z0-9]+$&quot;), &quot;&quot;)&#10;                return cleanCourseName.ifEmpty { courseNamePart }&#10;            }&#10;        }&#10;&#10;        // Fallback: return original subject&#10;        return subject&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/security/CredentialManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/data/security/CredentialManager.kt" />
              <option name="originalContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;import androidx.datastore.preferences.core.edit&#10;import androidx.datastore.preferences.core.emptyPreferences&#10;import androidx.datastore.preferences.core.stringPreferencesKey&#10;import androidx.security.crypto.EncryptedSharedPreferences&#10;import androidx.security.crypto.MasterKey&#10;import de.fampopprol.dhbwhorb.data.datastore.dataStore&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.catch&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.runBlocking&#10;import java.io.IOException&#10;&#10;/**&#10; * CredentialManager handles secure storage of user credentials using encrypted storage.&#10; *&#10; * Note: This class uses EncryptedSharedPreferences and MasterKey which are currently deprecated&#10; * but remain the recommended approach until a stable replacement is available.&#10; */&#10;@Suppress(&quot;DEPRECATION&quot;)&#10;class CredentialManager(context: Context) {&#10;@Suppress(&quot;DEPRECATION&quot;)&#10;&#10;@Suppress(&quot;DEPRECATION&quot;)&#10;    private val dataStore = context.dataStore&#10;@Suppress(&quot;DEPRECATION&quot;)&#10;&#10;    @Suppress(&quot;DEPRECATION&quot;)&#10;    @Suppress(&quot;DEPRECATION&quot;)&#10;    @Suppress(&quot;DEPRECATION&quot;)&#10;    @Suppress(&quot;DEPRECATION&quot;)&#10;    private val masterKey = MasterKey.Builder(context)&#10;        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)&#10;        .build()&#10;&#10;    @Suppress(&quot;DEPRECATION&quot;)&#10;    @Suppress(&quot;DEPRECATION&quot;)&#10;    @Suppress(&quot;DEPRECATION&quot;)&#10;    @Suppress(&quot;DEPRECATION&quot;)&#10;    private val encryptedSharedPreferences = EncryptedSharedPreferences.create(&#10;        context,&#10;        &quot;secure_credentials&quot;,&#10;        masterKey,&#10;        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,&#10;        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM&#10;    )&#10;&#10;    companion object {&#10;        private const val KEY_PASSWORD = &quot;password&quot;&#10;        private const val TAG = &quot;CredentialManager&quot;&#10;&#10;        private val KEY_USERNAME_DATASTORE = stringPreferencesKey(&quot;username&quot;)&#10;        private val KEY_IS_LOGGED_IN_DATASTORE = booleanPreferencesKey(&quot;is_logged_in&quot;)&#10;    }&#10;&#10;    /**&#10;     * Save credentials persistently (when user checks &quot;Remember me&quot;)&#10;     */&#10;    suspend fun saveCredentials(username: String, password: String) {&#10;        try {&#10;            encryptedSharedPreferences.edit {&#10;                putString(KEY_PASSWORD, password)&#10;            }&#10;            dataStore.edit { prefs -&gt;&#10;                prefs[KEY_USERNAME_DATASTORE] = username&#10;                prefs[KEY_IS_LOGGED_IN_DATASTORE] = true&#10;            }&#10;            Log.d(TAG, &quot;Credentials saved successfully&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error saving credentials&quot;, e)&#10;        }&#10;    }&#10;&#10;    val usernameFlow: Flow&lt;String?&gt; = dataStore.data&#10;        .catch { e -&gt;&#10;            if (e is IOException) {&#10;                emit(emptyPreferences())&#10;            } else {&#10;                throw e&#10;            }&#10;        }&#10;        .map { prefs -&gt;&#10;            prefs[KEY_USERNAME_DATASTORE]&#10;        }&#10;&#10;    fun getUsernameBlocking(): String? {&#10;        return runBlocking {&#10;            try {&#10;                dataStore.data.first()[KEY_USERNAME_DATASTORE]&#10;            } catch(_: Exception) {&#10;                null&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getPassword(): String? {&#10;        return try {&#10;            encryptedSharedPreferences.getString(KEY_PASSWORD, null)&#10;        } catch (_: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    fun isLoggedInBlocking(): Boolean {&#10;        return runBlocking {&#10;            try {&#10;                dataStore.data.first()[KEY_IS_LOGGED_IN_DATASTORE] ?: false&#10;            } catch(_: Exception) {&#10;                false&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun logout() {&#10;        try {&#10;            dataStore.edit { prefs -&gt;&#10;                prefs.remove(KEY_USERNAME_DATASTORE)&#10;                prefs[KEY_IS_LOGGED_IN_DATASTORE] = false&#10;            }&#10;            encryptedSharedPreferences.edit {&#10;                remove(KEY_PASSWORD)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.d(TAG, &quot;Error logging out&quot;, e)&#10;        }&#10;    }&#10;&#10;    suspend fun clearAllCredentials() {&#10;        try {&#10;            dataStore.edit { prefs -&gt; prefs.clear() }&#10;            encryptedSharedPreferences.edit { clear() }&#10;            Log.d(TAG, &quot;All credentials cleared&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error clearing credentials&quot;, e)&#10;        }&#10;    }&#10;&#10;    suspend fun hasStoredCredentialsBlocking(): Boolean {&#10;        val username = usernameFlow.first()&#10;        val password = getPassword()&#10;        return username != null &amp;&amp; password != null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;@file:Suppress(&quot;DEPRECATION&quot;)&#10;&#10;package de.fampopprol.dhbwhorb.data.security&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.core.content.edit&#10;import androidx.datastore.preferences.core.booleanPreferencesKey&#10;import androidx.datastore.preferences.core.edit&#10;import androidx.datastore.preferences.core.emptyPreferences&#10;import androidx.datastore.preferences.core.stringPreferencesKey&#10;import androidx.security.crypto.EncryptedSharedPreferences&#10;import androidx.security.crypto.MasterKey&#10;import de.fampopprol.dhbwhorb.data.datastore.dataStore&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.catch&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.runBlocking&#10;import java.io.IOException&#10;&#10;/**&#10; * CredentialManager handles secure storage of user credentials using encrypted storage.&#10; *&#10; * Note: This class uses EncryptedSharedPreferences and MasterKey which are currently deprecated&#10; * but remain the recommended approach until a stable replacement is available.&#10; */&#10;class CredentialManager(context: Context) {&#10;&#10;    private val dataStore = context.dataStore&#10;&#10;    private val masterKey = MasterKey.Builder(context)&#10;        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)&#10;        .build()&#10;&#10;    private val encryptedSharedPreferences = EncryptedSharedPreferences.create(&#10;        context,&#10;        &quot;secure_credentials&quot;,&#10;        masterKey,&#10;        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,&#10;        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM&#10;    )&#10;&#10;    companion object {&#10;        private const val KEY_PASSWORD = &quot;password&quot;&#10;        private const val TAG = &quot;CredentialManager&quot;&#10;&#10;        private val KEY_USERNAME_DATASTORE = stringPreferencesKey(&quot;username&quot;)&#10;        private val KEY_IS_LOGGED_IN_DATASTORE = booleanPreferencesKey(&quot;is_logged_in&quot;)&#10;    }&#10;&#10;    /**&#10;     * Save credentials persistently (when user checks &quot;Remember me&quot;)&#10;     */&#10;    suspend fun saveCredentials(username: String, password: String) {&#10;        try {&#10;            encryptedSharedPreferences.edit {&#10;                putString(KEY_PASSWORD, password)&#10;            }&#10;            dataStore.edit { prefs -&gt;&#10;                prefs[KEY_USERNAME_DATASTORE] = username&#10;                prefs[KEY_IS_LOGGED_IN_DATASTORE] = true&#10;            }&#10;            Log.d(TAG, &quot;Credentials saved successfully&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error saving credentials&quot;, e)&#10;        }&#10;    }&#10;&#10;    val usernameFlow: Flow&lt;String?&gt; = dataStore.data&#10;        .catch { e -&gt;&#10;            if (e is IOException) {&#10;                emit(emptyPreferences())&#10;            } else {&#10;                throw e&#10;            }&#10;        }&#10;        .map { prefs -&gt;&#10;            prefs[KEY_USERNAME_DATASTORE]&#10;        }&#10;&#10;    fun getUsernameBlocking(): String? {&#10;        return runBlocking {&#10;            try {&#10;                dataStore.data.first()[KEY_USERNAME_DATASTORE]&#10;            } catch(_: Exception) {&#10;                null&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getPassword(): String? {&#10;        return try {&#10;            encryptedSharedPreferences.getString(KEY_PASSWORD, null)&#10;        } catch (_: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    fun isLoggedInBlocking(): Boolean {&#10;        return runBlocking {&#10;            try {&#10;                dataStore.data.first()[KEY_IS_LOGGED_IN_DATASTORE] ?: false&#10;            } catch(_: Exception) {&#10;                false&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun logout() {&#10;        try {&#10;            dataStore.edit { prefs -&gt;&#10;                prefs.remove(KEY_USERNAME_DATASTORE)&#10;                prefs[KEY_IS_LOGGED_IN_DATASTORE] = false&#10;            }&#10;            encryptedSharedPreferences.edit {&#10;                remove(KEY_PASSWORD)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.d(TAG, &quot;Error logging out&quot;, e)&#10;        }&#10;    }&#10;&#10;    suspend fun clearAllCredentials() {&#10;        try {&#10;            dataStore.edit { prefs -&gt; prefs.clear() }&#10;            encryptedSharedPreferences.edit { clear() }&#10;            Log.d(TAG, &quot;All credentials cleared&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error clearing credentials&quot;, e)&#10;        }&#10;    }&#10;&#10;    suspend fun hasStoredCredentialsBlocking(): Boolean {&#10;        val username = usernameFlow.first()&#10;        val password = getPassword()&#10;        return username != null &amp;&amp; password != null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/NotificationSettingsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/NotificationSettingsScreen.kt" />
              <option name="originalContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen&#10;&#10;import android.os.Build&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Notifications&#10;import androidx.compose.material.icons.filled.NotificationsOff&#10;import androidx.compose.material.icons.filled.AccessTime&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material.icons.filled.Palette&#10;import androidx.compose.material.icons.filled.DarkMode&#10;import androidx.compose.material.icons.filled.LightMode&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.automirrored.filled.ExitToApp&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.DropdownMenu&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Switch&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import de.fampopprol.dhbwhorb.R&#10;import de.fampopprol.dhbwhorb.data.dualis.network.DualisService&#10;import de.fampopprol.dhbwhorb.data.notification.DHBWNotificationManager&#10;import de.fampopprol.dhbwhorb.data.notification.NotificationPreferencesManager&#10;import de.fampopprol.dhbwhorb.data.notification.NotificationScheduler&#10;import de.fampopprol.dhbwhorb.data.security.CredentialManager&#10;import de.fampopprol.dhbwhorb.data.theme.ThemePreferencesManager&#10;import de.fampopprol.dhbwhorb.ui.theme.ThemeMode&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun NotificationSettingsScreen(&#10;    dualisService: DualisService,&#10;    notificationScheduler: NotificationScheduler,&#10;    notificationPreferencesManager: NotificationPreferencesManager,&#10;    credentialManager: CredentialManager, // Add CredentialManager&#10;    onLogout: () -&gt; Unit, // Add onLogout callback&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    val context = LocalContext.current&#10;&#10;    // Theme preferences&#10;    val themePreferencesManager = remember { ThemePreferencesManager(context) }&#10;    val materialYouEnabled by themePreferencesManager.materialYouEnabled.collectAsState(initial = true)&#10;    val themeMode by themePreferencesManager.themeMode.collectAsState(initial = ThemeMode.SYSTEM)&#10;&#10;    val notificationsEnabled by notificationPreferencesManager.notificationsEnabled.collectAsState(initial = true)&#10;    val timetableNotificationsEnabled by notificationPreferencesManager.timetableNotificationsEnabled.collectAsState(initial = true)&#10;    val gradeNotificationsEnabled by notificationPreferencesManager.gradeNotificationsEnabled.collectAsState(initial = true)&#10;    val classReminderNotificationsEnabled by notificationPreferencesManager.classReminderNotificationsEnabled.collectAsState(initial = false)&#10;    val classReminderTimeMinutes by notificationPreferencesManager.classReminderTimeMinutes.collectAsState(initial = 30)&#10;&#10;    // Check if we're in demo mode&#10;    val isDemoMode = dualisService.isDemoMode()&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // ===== ALLGEMEINE EINSTELLUNGEN (GENERAL SETTINGS) SECTION =====&#10;        // General Settings Header&#10;        Row(&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Settings,&#10;                contentDescription = null,&#10;                tint = MaterialTheme.colorScheme.primary&#10;            )&#10;            Text(&#10;                text = stringResource(R.string.general_settings),&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Material You Theming Toggle (only show on Android 12+)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Column(modifier = Modifier.weight(1f)) {&#10;                            Text(&#10;                                text = stringResource(R.string.material_you_theming),&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                fontWeight = FontWeight.SemiBold&#10;                            )&#10;                            Text(&#10;                                text = stringResource(R.string.material_you_description),&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                        Switch(&#10;                            checked = materialYouEnabled,&#10;                            onCheckedChange = { enabled -&gt;&#10;                                scope.launch {&#10;                                    themePreferencesManager.setMaterialYouEnabled(enabled)&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Theme Mode Selection&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = when (themeMode) {&#10;                            ThemeMode.LIGHT -&gt; Icons.Default.LightMode&#10;                            ThemeMode.DARK -&gt; Icons.Default.DarkMode&#10;                            ThemeMode.SYSTEM -&gt; Icons.Default.Palette&#10;                        },&#10;                        contentDescription = null,&#10;                        tint = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = stringResource(R.string.theme_mode),&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.SemiBold&#10;                        )&#10;                        Text(&#10;                            text = stringResource(R.string.theme_mode_description),&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Theme mode selection buttons&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    ThemeMode.entries.forEach { mode -&gt;&#10;                        val isSelected = themeMode == mode&#10;                        Card(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .clickable {&#10;                                    scope.launch {&#10;                                        themePreferencesManager.setThemeMode(mode)&#10;                                    }&#10;                                },&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = if (isSelected)&#10;                                    MaterialTheme.colorScheme.primaryContainer&#10;                                else&#10;                                    MaterialTheme.colorScheme.surfaceVariant&#10;                            )&#10;                        ) {&#10;                            Column(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(12.dp),&#10;                                horizontalAlignment = Alignment.CenterHorizontally,&#10;                                verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                            ) {&#10;                                Icon(&#10;                                    imageVector = when (mode) {&#10;                                        ThemeMode.LIGHT -&gt; Icons.Default.LightMode&#10;                                        ThemeMode.DARK -&gt; Icons.Default.DarkMode&#10;                                        ThemeMode.SYSTEM -&gt; Icons.Default.Palette&#10;                                    },&#10;                                    contentDescription = null,&#10;                                    tint = if (isSelected)&#10;                                        MaterialTheme.colorScheme.onPrimaryContainer&#10;                                    else&#10;                                        MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                                Text(&#10;                                    text = stringResource(when (mode) {&#10;                                        ThemeMode.LIGHT -&gt; R.string.theme_light&#10;                                        ThemeMode.DARK -&gt; R.string.theme_dark&#10;                                        ThemeMode.SYSTEM -&gt; R.string.theme_system&#10;                                    }),&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal,&#10;                                    color = if (isSelected)&#10;                                        MaterialTheme.colorScheme.onPrimaryContainer&#10;                                    else&#10;                                        MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // ===== NOTIFICATION SETTINGS SECTION =====&#10;        // Notification Settings Header&#10;        Row(&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = if (notificationsEnabled) Icons.Default.Notifications else Icons.Default.NotificationsOff,&#10;                contentDescription = null,&#10;                tint = MaterialTheme.colorScheme.primary&#10;            )&#10;            Text(&#10;                text = stringResource(R.string.notification_settings),&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Master notification toggle&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = stringResource(R.string.enable_notifications),&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.SemiBold&#10;                        )&#10;                        Text(&#10;                            text = stringResource(R.string.enable_notifications_description),&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                    Switch(&#10;                        checked = notificationsEnabled,&#10;                        onCheckedChange = { enabled -&gt;&#10;                            scope.launch {&#10;                                notificationPreferencesManager.setNotificationsEnabled(enabled)&#10;                                if (enabled) {&#10;                                    notificationScheduler.schedulePeriodicNotifications()&#10;                                } else {&#10;                                    notificationScheduler.cancelPeriodicNotifications()&#10;                                }&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Timetable notifications&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = stringResource(R.string.timetable_changes),&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;                        Text(&#10;                            text = stringResource(R.string.timetable_changes_description),&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                    Switch(&#10;                        checked = timetableNotificationsEnabled,&#10;                        enabled = notificationsEnabled,&#10;                        onCheckedChange = { enabled -&gt;&#10;                            scope.launch {&#10;                                notificationPreferencesManager.setTimetableNotificationsEnabled(enabled)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Grade notifications&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = stringResource(R.string.new_grades),&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;                        Text(&#10;                            text = stringResource(R.string.new_grades_description),&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                    Switch(&#10;                        checked = gradeNotificationsEnabled,&#10;                        enabled = notificationsEnabled,&#10;                        onCheckedChange = { enabled -&gt;&#10;                            scope.launch {&#10;                                notificationPreferencesManager.setGradeNotificationsEnabled(enabled)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Class reminder notifications&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = stringResource(R.string.class_reminders),&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;                        Text(&#10;                            text = stringResource(R.string.class_reminders_description),&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                    Switch(&#10;                        checked = classReminderNotificationsEnabled,&#10;                        enabled = notificationsEnabled,&#10;                        onCheckedChange = { enabled -&gt;&#10;                            scope.launch {&#10;                                notificationPreferencesManager.setClassReminderNotificationsEnabled(enabled)&#10;                                if (enabled) {&#10;                                    notificationScheduler.scheduleClassReminders()&#10;                                } else {&#10;                                    notificationScheduler.cancelClassReminders()&#10;                                }&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;&#10;                // Time picker for reminder timing&#10;                if (classReminderNotificationsEnabled &amp;&amp; notificationsEnabled) {&#10;                    var showDropdown by remember { mutableStateOf(false) }&#10;                    val timeOptions = listOf(5, 10, 15, 30, 45, 60, 90, 120)&#10;&#10;                    Card(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable { showDropdown = true },&#10;                        colors = CardDefaults.cardColors(&#10;                            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                        )&#10;                    ) {&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(12.dp),&#10;                            horizontalArrangement = Arrangement.SpaceBetween,&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Row(&#10;                                verticalAlignment = Alignment.CenterVertically,&#10;                                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                            ) {&#10;                                Icon(&#10;                                    imageVector = Icons.Default.AccessTime,&#10;                                    contentDescription = null,&#10;                                    tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                                Column {&#10;                                    Text(&#10;                                        text = stringResource(R.string.reminder_time),&#10;                                        style = MaterialTheme.typography.bodyMedium,&#10;                                        fontWeight = FontWeight.Medium&#10;                                    )&#10;                                    Text(&#10;                                        text = stringResource(R.string.minutes_before_class, classReminderTimeMinutes),&#10;                                        style = MaterialTheme.typography.bodySmall,&#10;                                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        DropdownMenu(&#10;                            expanded = showDropdown,&#10;                            onDismissRequest = { showDropdown = false }&#10;                        ) {&#10;                            timeOptions.forEach { minutes -&gt;&#10;                                DropdownMenuItem(&#10;                                    text = {&#10;                                        Text(&#10;                                            text = if (minutes == 1) stringResource(R.string.one_minute) else stringResource(R.string.x_minutes, minutes),&#10;                                            color = if (minutes == classReminderTimeMinutes)&#10;                                                MaterialTheme.colorScheme.primary&#10;                                            else MaterialTheme.colorScheme.onSurface&#10;                                        )&#10;                                    },&#10;                                    onClick = {&#10;                                        scope.launch {&#10;                                            notificationPreferencesManager.setClassReminderTimeMinutes(minutes)&#10;                                            notificationScheduler.scheduleClassReminders() // Reschedule with new time&#10;                                        }&#10;                                        showDropdown = false&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Demo notification test buttons (only show in demo mode)&#10;        if (isDemoMode) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.tertiaryContainer&#10;                )&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Notifications,&#10;                            contentDescription = null,&#10;                            tint = MaterialTheme.colorScheme.onTertiaryContainer&#10;                        )&#10;                        Text(&#10;                            text = stringResource(R.string.demo_mode_test_notifications),&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.SemiBold,&#10;                            color = MaterialTheme.colorScheme.onTertiaryContainer&#10;                        )&#10;                    }&#10;&#10;                    Text(&#10;                        text = stringResource(R.string.test_notifications_description),&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onTertiaryContainer.copy(alpha = 0.8f)&#10;                    )&#10;&#10;                    // Test Timetable Change Notification Button&#10;                    Button(&#10;                        onClick = {&#10;                            val notificationManager = DHBWNotificationManager(context)&#10;                            val demoChanges = listOf(&#10;                                &quot;Software Engineering moved to room HOR-120&quot;,&#10;                                &quot;Database Systems time changed to 10:00-11:30&quot;&#10;                            )&#10;                            notificationManager.showTimetableChangeNotification(demoChanges)&#10;                        },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.DateRange,&#10;                            contentDescription = null,&#10;                            modifier = Modifier.padding(end = 8.dp)&#10;                        )&#10;                        Text(stringResource(R.string.test_timetable_change))&#10;                    }&#10;&#10;                    // Test Grade Change Notification Button&#10;                    Button(&#10;                        onClick = {&#10;                            val notificationManager = DHBWNotificationManager(context)&#10;                            val demoGrades = listOf(&#10;                                &quot;New grade available: Software Engineering - 1.3&quot;,&#10;                                &quot;New grade available: Database Systems - 1.7&quot;&#10;                            )&#10;                            notificationManager.showGradeChangeNotification(demoGrades)&#10;                        },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = MaterialTheme.colorScheme.secondary&#10;                        )&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Star,&#10;                            contentDescription = null,&#10;                            modifier = Modifier.padding(end = 8.dp)&#10;                        )&#10;                        Text(stringResource(R.string.test_grade_change))&#10;                    }&#10;&#10;                    // Test Class Reminder Notification Button&#10;                    Button(&#10;                        onClick = {&#10;                            val notificationManager = DHBWNotificationManager(context)&#10;                            val reminderText = &quot;Software Engineering starts in 30 minutes in room HOR-120&quot;&#10;                            notificationManager.showClassReminderNotification(reminderText, 3001)&#10;                        },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = MaterialTheme.colorScheme.tertiary&#10;                        )&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.AccessTime,&#10;                            contentDescription = null,&#10;                            modifier = Modifier.padding(end = 8.dp)&#10;                        )&#10;                        Text(stringResource(R.string.test_class_reminder))&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Information card&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;            )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Text(&#10;                    text = stringResource(R.string.how_it_works),&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;                Text(&#10;                    text = stringResource(R.string.how_it_works_description),&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;        }&#10;&#10;        // Logout Button&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        Button(&#10;            onClick = {&#10;                scope.launch {&#10;                    credentialManager.logout()&#10;                    onLogout()&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            colors = ButtonDefaults.buttonColors(&#10;                containerColor = MaterialTheme.colorScheme.errorContainer,&#10;                contentColor = MaterialTheme.colorScheme.onErrorContainer&#10;            )&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.AutoMirrored.Filled.ExitToApp,&#10;                contentDescription = null,&#10;                modifier = Modifier.padding(end = 8.dp)&#10;            )&#10;            Text(stringResource(R.string.logout))&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.dp&#10;import de.fampopprol.dhbwhorb.data.dualis.network.DualisService&#10;import de.fampopprol.dhbwhorb.data.notification.NotificationPreferencesManager&#10;import de.fampopprol.dhbwhorb.data.notification.NotificationScheduler&#10;import de.fampopprol.dhbwhorb.data.security.CredentialManager&#10;import de.fampopprol.dhbwhorb.data.theme.ThemePreferencesManager&#10;import de.fampopprol.dhbwhorb.ui.screen.notificationSettingsScreen.ClassReminderSettingsSection&#10;import de.fampopprol.dhbwhorb.ui.screen.notificationSettingsScreen.DemoModeTestSection&#10;import de.fampopprol.dhbwhorb.ui.screen.notificationSettingsScreen.GeneralSettingsSection&#10;import de.fampopprol.dhbwhorb.ui.screen.notificationSettingsScreen.LogoutSection&#10;import de.fampopprol.dhbwhorb.ui.screen.notificationSettingsScreen.NotificationSettingsSection&#10;&#10;@Composable&#10;fun NotificationSettingsScreen(&#10;    dualisService: DualisService,&#10;    notificationScheduler: NotificationScheduler,&#10;    notificationPreferencesManager: NotificationPreferencesManager,&#10;    credentialManager: CredentialManager,&#10;    onLogout: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;    val themePreferencesManager = remember { ThemePreferencesManager(context) }&#10;&#10;    val notificationsEnabled by notificationPreferencesManager.notificationsEnabled.collectAsState(initial = true)&#10;    val isDemoMode = dualisService.isDemoMode()&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // General Settings Section&#10;        GeneralSettingsSection(&#10;            themePreferencesManager = themePreferencesManager&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // Notification Settings Section&#10;        NotificationSettingsSection(&#10;            notificationPreferencesManager = notificationPreferencesManager,&#10;            notificationScheduler = notificationScheduler&#10;        )&#10;&#10;        // Class Reminder Settings Section&#10;        ClassReminderSettingsSection(&#10;            notificationPreferencesManager = notificationPreferencesManager,&#10;            notificationScheduler = notificationScheduler,&#10;            notificationsEnabled = notificationsEnabled&#10;        )&#10;&#10;        // Demo Mode Test Section (only show in demo mode)&#10;        if (isDemoMode) {&#10;            DemoModeTestSection()&#10;        }&#10;&#10;        // Logout Section&#10;        LogoutSection(&#10;            credentialManager = credentialManager,&#10;            onLogout = onLogout&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/gradesScreen/GradesAuthManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/gradesScreen/GradesAuthManager.kt" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.gradesScreen&#10;&#10;import android.util.Log&#10;import de.fampopprol.dhbwhorb.data.dualis.network.DualisService&#10;import de.fampopprol.dhbwhorb.data.security.CredentialManager&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Handles authentication logic for the grades screen&#10; */&#10;class GradesAuthManager(&#10;    private val dualisService: DualisService,&#10;    private val credentialManager: CredentialManager?,&#10;    private val scope: CoroutineScope&#10;) {&#10;    &#10;    enum class AuthResult {&#10;        SUCCESS,&#10;        FAILED,&#10;        NO_CREDENTIALS,&#10;        NO_STORED_CREDENTIALS&#10;    }&#10;&#10;    /**&#10;     * Ensures the user is authenticated before proceeding with data operations&#10;     * @param onResult Callback with the authentication result&#10;     */&#10;    fun ensureAuthentication(onResult: (AuthResult) -&gt; Unit) {&#10;        // If already authenticated, return success immediately&#10;        if (dualisService.isAuthenticated()) {&#10;            onResult(AuthResult.SUCCESS)&#10;            return&#10;        }&#10;&#10;        // Check if we have stored credentials to re-authenticate&#10;        if (credentialManager == null) {&#10;            onResult(AuthResult.NO_CREDENTIALS)&#10;            return&#10;        }&#10;&#10;        scope.launch {&#10;            val hasStoredCredentials = credentialManager.hasStoredCredentialsBlocking()&#10;            if (hasStoredCredentials) {&#10;                val username = credentialManager.getUsernameBlocking()&#10;                val password = credentialManager.getPassword()&#10;&#10;                if (username != null &amp;&amp; password != null) {&#10;                    Log.d(&quot;GradesAuthManager&quot;, &quot;Re-authenticating with stored credentials&quot;)&#10;                    dualisService.login(username, password) { result -&gt;&#10;                        if (result != null) {&#10;                            Log.d(&quot;GradesAuthManager&quot;, &quot;Re-authentication successful&quot;)&#10;                            onResult(AuthResult.SUCCESS)&#10;                        } else {&#10;                            Log.e(&quot;GradesAuthManager&quot;, &quot;Re-authentication failed&quot;)&#10;                            onResult(AuthResult.FAILED)&#10;                        }&#10;                    }&#10;                } else {&#10;                    Log.e(&quot;GradesAuthManager&quot;, &quot;No valid stored credentials found&quot;)&#10;                    onResult(AuthResult.NO_STORED_CREDENTIALS)&#10;                }&#10;            } else {&#10;                Log.e(&quot;GradesAuthManager&quot;, &quot;No stored credentials available&quot;)&#10;                onResult(AuthResult.NO_STORED_CREDENTIALS)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/notificationSettingsScreen/ClassReminderSettingsSection.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/notificationSettingsScreen/ClassReminderSettingsSection.kt" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.notificationSettingsScreen&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.AccessTime&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.DropdownMenu&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Switch&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import de.fampopprol.dhbwhorb.R&#10;import de.fampopprol.dhbwhorb.data.notification.NotificationPreferencesManager&#10;import de.fampopprol.dhbwhorb.data.notification.NotificationScheduler&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun ClassReminderSettingsSection(&#10;    notificationPreferencesManager: NotificationPreferencesManager,&#10;    notificationScheduler: NotificationScheduler,&#10;    notificationsEnabled: Boolean,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    val classReminderNotificationsEnabled by notificationPreferencesManager.classReminderNotificationsEnabled.collectAsState(initial = false)&#10;    val classReminderTimeMinutes by notificationPreferencesManager.classReminderTimeMinutes.collectAsState(initial = 30)&#10;&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = stringResource(R.string.class_reminders),&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Text(&#10;                        text = stringResource(R.string.class_reminders_description),&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;                Switch(&#10;                    checked = classReminderNotificationsEnabled,&#10;                    enabled = notificationsEnabled,&#10;                    onCheckedChange = { enabled -&gt;&#10;                        scope.launch {&#10;                            notificationPreferencesManager.setClassReminderNotificationsEnabled(enabled)&#10;                            if (enabled) {&#10;                                notificationScheduler.scheduleClassReminders()&#10;                            } else {&#10;                                notificationScheduler.cancelClassReminders()&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;&#10;            // Time picker for reminder timing&#10;            if (classReminderNotificationsEnabled &amp;&amp; notificationsEnabled) {&#10;                var showDropdown by remember { mutableStateOf(false) }&#10;                val timeOptions = listOf(5, 10, 15, 30, 45, 60, 90, 120)&#10;&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable { showDropdown = true },&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                    )&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(12.dp),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically,&#10;                            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.AccessTime,&#10;                                contentDescription = null,&#10;                                tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                            Column {&#10;                                Text(&#10;                                    text = stringResource(R.string.reminder_time),&#10;                                    style = MaterialTheme.typography.bodyMedium,&#10;                                    fontWeight = FontWeight.Medium&#10;                                )&#10;                                Text(&#10;                                    text = stringResource(R.string.minutes_before_class, classReminderTimeMinutes),&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    DropdownMenu(&#10;                        expanded = showDropdown,&#10;                        onDismissRequest = { showDropdown = false }&#10;                    ) {&#10;                        timeOptions.forEach { minutes -&gt;&#10;                            DropdownMenuItem(&#10;                                text = {&#10;                                    Text(&#10;                                        text = if (minutes == 1) stringResource(R.string.one_minute) else stringResource(R.string.x_minutes, minutes),&#10;                                        color = if (minutes == classReminderTimeMinutes)&#10;                                            MaterialTheme.colorScheme.primary&#10;                                        else MaterialTheme.colorScheme.onSurface&#10;                                    )&#10;                                },&#10;                                onClick = {&#10;                                    scope.launch {&#10;                                        notificationPreferencesManager.setClassReminderTimeMinutes(minutes)&#10;                                        notificationScheduler.scheduleClassReminders() // Reschedule with new time&#10;                                    }&#10;                                    showDropdown = false&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/notificationSettingsScreen/DemoModeTestSection.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/notificationSettingsScreen/DemoModeTestSection.kt" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.notificationSettingsScreen&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material.icons.filled.Notifications&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import de.fampopprol.dhbwhorb.R&#10;import de.fampopprol.dhbwhorb.data.notification.DHBWNotificationManager&#10;&#10;@Composable&#10;fun DemoModeTestSection(&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.tertiaryContainer&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Notifications,&#10;                    contentDescription = null,&#10;                    tint = MaterialTheme.colorScheme.onTertiaryContainer&#10;                )&#10;                Text(&#10;                    text = stringResource(R.string.demo_mode_test_notifications),&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    color = MaterialTheme.colorScheme.onTertiaryContainer&#10;                )&#10;            }&#10;&#10;            Text(&#10;                text = stringResource(R.string.test_notifications_description),&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onTertiaryContainer.copy(alpha = 0.8f)&#10;            )&#10;&#10;            // Test Timetable Change Notification Button&#10;            Button(&#10;                onClick = {&#10;                    val notificationManager = DHBWNotificationManager(context)&#10;                    val demoChanges = listOf(&#10;                        &quot;Software Engineering moved to room HOR-120&quot;,&#10;                        &quot;Database Systems time changed to 10:00-11:30&quot;&#10;                    )&#10;                    notificationManager.showTimetableChangeNotification(demoChanges)&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.primary&#10;                )&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.DateRange,&#10;                    contentDescription = null,&#10;                    modifier = Modifier.padding(end = 8.dp)&#10;                )&#10;                Text(stringResource(R.string.test_timetable_change))&#10;            }&#10;&#10;            // Test Grade Change Notification Button&#10;            Button(&#10;                onClick = {&#10;                    val notificationManager = DHBWNotificationManager(context)&#10;                    val demoGrades = listOf(&#10;                        &quot;New grade available: Software Engineering - 1.3&quot;,&#10;                        &quot;New grade available: Database Systems - 1.7&quot;&#10;                    )&#10;                    notificationManager.showGradeChangeNotification(demoGrades)&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.secondary&#10;                )&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Star,&#10;                    contentDescription = null,&#10;                    modifier = Modifier.padding(end = 8.dp)&#10;                )&#10;                Text(stringResource(R.string.test_grade_change))&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/notificationSettingsScreen/GeneralSettingsSection.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/notificationSettingsScreen/GeneralSettingsSection.kt" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.notificationSettingsScreen&#10;&#10;import android.os.Build&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.DarkMode&#10;import androidx.compose.material.icons.filled.LightMode&#10;import androidx.compose.material.icons.filled.Palette&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Switch&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import de.fampopprol.dhbwhorb.R&#10;import de.fampopprol.dhbwhorb.data.theme.ThemePreferencesManager&#10;import de.fampopprol.dhbwhorb.ui.theme.ThemeMode&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun GeneralSettingsSection(&#10;    themePreferencesManager: ThemePreferencesManager,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    val materialYouEnabled by themePreferencesManager.materialYouEnabled.collectAsState(initial = true)&#10;    val themeMode by themePreferencesManager.themeMode.collectAsState(initial = ThemeMode.SYSTEM)&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // General Settings Header&#10;        Row(&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Settings,&#10;                contentDescription = null,&#10;                tint = MaterialTheme.colorScheme.primary&#10;            )&#10;            Text(&#10;                text = stringResource(R.string.general_settings),&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Material You Theming Toggle (only show on Android 12+)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Column(modifier = Modifier.weight(1f)) {&#10;                            Text(&#10;                                text = stringResource(R.string.material_you_theming),&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                fontWeight = FontWeight.SemiBold&#10;                            )&#10;                            Text(&#10;                                text = stringResource(R.string.material_you_description),&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                        Switch(&#10;                            checked = materialYouEnabled,&#10;                            onCheckedChange = { enabled -&gt;&#10;                                scope.launch {&#10;                                    themePreferencesManager.setMaterialYouEnabled(enabled)&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Theme Mode Selection&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = when (themeMode) {&#10;                            ThemeMode.LIGHT -&gt; Icons.Default.LightMode&#10;                            ThemeMode.DARK -&gt; Icons.Default.DarkMode&#10;                            ThemeMode.SYSTEM -&gt; Icons.Default.Palette&#10;                        },&#10;                        contentDescription = null,&#10;                        tint = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = stringResource(R.string.theme_mode),&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.SemiBold&#10;                        )&#10;                        Text(&#10;                            text = stringResource(R.string.theme_mode_description),&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Theme mode selection buttons&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    ThemeMode.entries.forEach { mode -&gt;&#10;                        val isSelected = themeMode == mode&#10;                        Card(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .clickable {&#10;                                    scope.launch {&#10;                                        themePreferencesManager.setThemeMode(mode)&#10;                                    }&#10;                                },&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = if (isSelected)&#10;                                    MaterialTheme.colorScheme.primaryContainer&#10;                                else&#10;                                    MaterialTheme.colorScheme.surfaceVariant&#10;                            )&#10;                        ) {&#10;                            Column(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(12.dp),&#10;                                horizontalAlignment = Alignment.CenterHorizontally,&#10;                                verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                            ) {&#10;                                Icon(&#10;                                    imageVector = when (mode) {&#10;                                        ThemeMode.LIGHT -&gt; Icons.Default.LightMode&#10;                                        ThemeMode.DARK -&gt; Icons.Default.DarkMode&#10;                                        ThemeMode.SYSTEM -&gt; Icons.Default.Palette&#10;                                    },&#10;                                    contentDescription = null,&#10;                                    tint = if (isSelected)&#10;                                        MaterialTheme.colorScheme.onPrimaryContainer&#10;                                    else&#10;                                        MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                                Text(&#10;                                    text = stringResource(when (mode) {&#10;                                        ThemeMode.LIGHT -&gt; R.string.theme_light&#10;                                        ThemeMode.DARK -&gt; R.string.theme_dark&#10;                                        ThemeMode.SYSTEM -&gt; R.string.theme_system&#10;                                    }),&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal,&#10;                                    color = if (isSelected)&#10;                                        MaterialTheme.colorScheme.onPrimaryContainer&#10;                                    else&#10;                                        MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/notificationSettingsScreen/LogoutSection.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/notificationSettingsScreen/LogoutSection.kt" />
              <option name="originalContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.notificationSettingsScreen&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ExitToApp&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import de.fampopprol.dhbwhorb.R&#10;import de.fampopprol.dhbwhorb.data.security.CredentialManager&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun LogoutSection(&#10;    credentialManager: CredentialManager,&#10;    onLogout: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.errorContainer&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            Text(&#10;                text = stringResource(R.string.general_settings), // Using existing string resource&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.SemiBold,&#10;                color = MaterialTheme.colorScheme.onErrorContainer&#10;            )&#10;&#10;            Text(&#10;                text = stringResource(R.string.enable_notifications_description), // Using existing string resource as placeholder&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onErrorContainer.copy(alpha = 0.8f)&#10;            )&#10;&#10;            Button(&#10;                onClick = {&#10;                    scope.launch {&#10;                        credentialManager.clearStoredCredentials() // Using correct method name&#10;                        onLogout()&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.error&#10;                )&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.ExitToApp,&#10;                    contentDescription = null,&#10;                    modifier = Modifier.padding(end = 8.dp)&#10;                )&#10;                Text(&#10;                    text = stringResource(R.string.general_settings), // Using existing string resource as placeholder&#10;                    color = MaterialTheme.colorScheme.onError&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.notificationSettingsScreen&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ExitToApp&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import de.fampopprol.dhbwhorb.R&#10;import de.fampopprol.dhbwhorb.data.security.CredentialManager&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun LogoutSection(&#10;    credentialManager: CredentialManager,&#10;    onLogout: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.errorContainer&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            Text(&#10;                text = stringResource(R.string.general_settings), // Using existing string resource&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.SemiBold,&#10;                color = MaterialTheme.colorScheme.onErrorContainer&#10;            )&#10;&#10;            Text(&#10;                text = stringResource(R.string.enable_notifications_description), // Using existing string resource as placeholder&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onErrorContainer.copy(alpha = 0.8f)&#10;            )&#10;&#10;            Button(&#10;                onClick = {&#10;                    scope.launch {&#10;                        credentialManager.clearAllCredentials() // Using correct method name&#10;                        onLogout()&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.error&#10;                )&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.ExitToApp,&#10;                    contentDescription = null,&#10;                    modifier = Modifier.padding(end = 8.dp)&#10;                )&#10;                Text(&#10;                    text = stringResource(R.string.general_settings), // Using existing string resource as placeholder&#10;                    color = MaterialTheme.colorScheme.onError&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/notificationSettingsScreen/NotificationSettingsSection.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/notificationSettingsScreen/NotificationSettingsSection.kt" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.notificationSettingsScreen&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Notifications&#10;import androidx.compose.material.icons.filled.NotificationsOff&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Switch&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import de.fampopprol.dhbwhorb.R&#10;import de.fampopprol.dhbwhorb.data.notification.NotificationPreferencesManager&#10;import de.fampopprol.dhbwhorb.data.notification.NotificationScheduler&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun NotificationSettingsSection(&#10;    notificationPreferencesManager: NotificationPreferencesManager,&#10;    notificationScheduler: NotificationScheduler,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    val notificationsEnabled by notificationPreferencesManager.notificationsEnabled.collectAsState(initial = true)&#10;    val timetableNotificationsEnabled by notificationPreferencesManager.timetableNotificationsEnabled.collectAsState(initial = true)&#10;    val gradeNotificationsEnabled by notificationPreferencesManager.gradeNotificationsEnabled.collectAsState(initial = true)&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Notification Settings Header&#10;        Row(&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = if (notificationsEnabled) Icons.Default.Notifications else Icons.Default.NotificationsOff,&#10;                contentDescription = null,&#10;                tint = MaterialTheme.colorScheme.primary&#10;            )&#10;            Text(&#10;                text = stringResource(R.string.notification_settings),&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Master notification toggle&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = stringResource(R.string.enable_notifications),&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.SemiBold&#10;                        )&#10;                        Text(&#10;                            text = stringResource(R.string.enable_notifications_description),&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                    Switch(&#10;                        checked = notificationsEnabled,&#10;                        onCheckedChange = { enabled -&gt;&#10;                            scope.launch {&#10;                                notificationPreferencesManager.setNotificationsEnabled(enabled)&#10;                                if (enabled) {&#10;                                    notificationScheduler.schedulePeriodicNotifications()&#10;                                } else {&#10;                                    notificationScheduler.cancelPeriodicNotifications()&#10;                                }&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Timetable notifications&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = stringResource(R.string.timetable_changes),&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;                        Text(&#10;                            text = stringResource(R.string.timetable_changes_description),&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                    Switch(&#10;                        checked = timetableNotificationsEnabled,&#10;                        enabled = notificationsEnabled,&#10;                        onCheckedChange = { enabled -&gt;&#10;                            scope.launch {&#10;                                notificationPreferencesManager.setTimetableNotificationsEnabled(enabled)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Grade notifications&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = stringResource(R.string.new_grades),&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;                        Text(&#10;                            text = stringResource(R.string.new_grades_description),&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                    Switch(&#10;                        checked = gradeNotificationsEnabled,&#10;                        enabled = notificationsEnabled,&#10;                        onCheckedChange = { enabled -&gt;&#10;                            scope.launch {&#10;                                notificationPreferencesManager.setGradeNotificationsEnabled(enabled)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/settingsScreen/ClassReminderSettingsSection.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/settingsScreen/ClassReminderSettingsSection.kt" />
              <option name="originalContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.settingsScreen&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.AccessTime&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.material3.DropdownMenu&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Switch&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.AccessTime&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.material3.DropdownMenu&#10;import de.fampopprol.dhbwhorb.R&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.Icon&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.AccessTime&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;    val scope = rememberCoroutineScope()&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.material3.DropdownMenu&#10;import de.fampopprol.dhbwhorb.R&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.Icon&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.AccessTime&#10;import androidx.compose.material3.Card&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = stringResource(R.string.class_reminders),&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Text(&#10;                        text = stringResource(R.string.class_reminders_description),&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;                Switch(&#10;                    checked = classReminderNotificationsEnabled,&#10;                    enabled = notificationsEnabled,&#10;                    onCheckedChange = { enabled -&gt;&#10;                        scope.launch {&#10;                            notificationPreferencesManager.setClassReminderNotificationsEnabled(enabled)&#10;                            if (enabled) {&#10;                                notificationScheduler.scheduleClassReminders()&#10;                            } else {&#10;                                notificationScheduler.cancelClassReminders()&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;import androidx.compose.material3.CardDefaults&#10;            // Time picker for reminder timing&#10;    Card(&#10;                var showDropdown by remember { mutableStateOf(false) }&#10;                val timeOptions = listOf(5, 10, 15, 30, 45, 60, 90, 120)&#10;import androidx.compose.ui.res.stringResource&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable { showDropdown = true },&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                    )&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(12.dp),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically,&#10;                            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.AccessTime,&#10;                                contentDescription = null,&#10;                                tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                            Column {&#10;                                Text(&#10;                                    text = stringResource(R.string.reminder_time),&#10;                                    style = MaterialTheme.typography.bodyMedium,&#10;                                    fontWeight = FontWeight.Medium&#10;                                )&#10;                                Text(&#10;                                    text = stringResource(R.string.minutes_before_class, classReminderTimeMinutes),&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    DropdownMenu(&#10;                        expanded = showDropdown,&#10;                        onDismissRequest = { showDropdown = false }&#10;                    ) {&#10;                        timeOptions.forEach { minutes -&gt;&#10;                            DropdownMenuItem(&#10;                                text = {&#10;                                    Text(&#10;                                        text = if (minutes == 1) stringResource(R.string.one_minute) else stringResource(R.string.x_minutes, minutes),&#10;                                        color = if (minutes == classReminderTimeMinutes)&#10;                                            MaterialTheme.colorScheme.primary&#10;                                        else MaterialTheme.colorScheme.onSurface&#10;                                    )&#10;                                },&#10;                                onClick = {&#10;                                    scope.launch {&#10;                                        notificationPreferencesManager.setClassReminderTimeMinutes(minutes)&#10;                                        notificationScheduler.scheduleClassReminders() // Reschedule with new time&#10;                                    }&#10;                                    showDropdown = false&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = stringResource(R.string.class_reminders),&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Text(&#10;                        text = stringResource(R.string.class_reminders_description),&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;                Switch(&#10;                    checked = classReminderNotificationsEnabled,&#10;                    enabled = notificationsEnabled,&#10;                    onCheckedChange = { enabled -&gt;&#10;                        scope.launch {&#10;                            notificationPreferencesManager.setClassReminderNotificationsEnabled(enabled)&#10;                            if (enabled) {&#10;                                notificationScheduler.scheduleClassReminders()&#10;                            } else {&#10;                                notificationScheduler.cancelClassReminders()&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;import androidx.compose.ui.Modifier&#10;            // Time picker for reminder timing&#10;import androidx.compose.ui.text.font.FontWeight&#10;                var showDropdown by remember { mutableStateOf(false) }&#10;                val timeOptions = listOf(5, 10, 15, 30, 45, 60, 90, 120)&#10;&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable { showDropdown = true },&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                    )&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(12.dp),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically,&#10;                            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.AccessTime,&#10;                                contentDescription = null,&#10;                                tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                            Column {&#10;                                Text(&#10;                                    text = stringResource(R.string.reminder_time),&#10;                                    style = MaterialTheme.typography.bodyMedium,&#10;                                    fontWeight = FontWeight.Medium&#10;                                )&#10;                                Text(&#10;                                    text = stringResource(R.string.minutes_before_class, classReminderTimeMinutes),&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    DropdownMenu(&#10;                        expanded = showDropdown,&#10;                        onDismissRequest = { showDropdown = false }&#10;                    ) {&#10;                        timeOptions.forEach { minutes -&gt;&#10;                            DropdownMenuItem(&#10;                                text = {&#10;                                    Text(&#10;                                        text = if (minutes == 1) stringResource(R.string.one_minute) else stringResource(R.string.x_minutes, minutes),&#10;                                        color = if (minutes == classReminderTimeMinutes)&#10;                                            MaterialTheme.colorScheme.primary&#10;                                        else MaterialTheme.colorScheme.onSurface&#10;                                    )&#10;                                },&#10;                                onClick = {&#10;                                    scope.launch {&#10;                                        notificationPreferencesManager.setClassReminderTimeMinutes(minutes)&#10;                                        notificationScheduler.scheduleClassReminders() // Reschedule with new time&#10;                                    }&#10;                                    showDropdown = false&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = stringResource(R.string.class_reminders),&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Text(&#10;                        text = stringResource(R.string.class_reminders_description),&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;                Switch(&#10;                    checked = classReminderNotificationsEnabled,&#10;                    enabled = notificationsEnabled,&#10;                    onCheckedChange = { enabled -&gt;&#10;                        scope.launch {&#10;                            notificationPreferencesManager.setClassReminderNotificationsEnabled(enabled)&#10;                            if (enabled) {&#10;                                notificationScheduler.scheduleClassReminders()&#10;                            } else {&#10;                                notificationScheduler.cancelClassReminders()&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;    val classReminderTimeMinutes by notificationPreferencesManager.classReminderTimeMinutes.collectAsState(initial = 30)&#10;            // Time picker for reminder timing&#10;    Card(&#10;                var showDropdown by remember { mutableStateOf(false) }&#10;                val timeOptions = listOf(5, 10, 15, 30, 45, 60, 90, 120)&#10;&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable { showDropdown = true },&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                    )&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(12.dp),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically,&#10;                            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.AccessTime,&#10;                                contentDescription = null,&#10;                                tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                            Column {&#10;                                Text(&#10;                                    text = stringResource(R.string.reminder_time),&#10;                                    style = MaterialTheme.typography.bodyMedium,&#10;                                    fontWeight = FontWeight.Medium&#10;                                )&#10;                                Text(&#10;                                    text = stringResource(R.string.minutes_before_class, classReminderTimeMinutes),&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    DropdownMenu(&#10;                        expanded = showDropdown,&#10;                        onDismissRequest = { showDropdown = false }&#10;                    ) {&#10;                        timeOptions.forEach { minutes -&gt;&#10;                            DropdownMenuItem(&#10;                                text = {&#10;                                    Text(&#10;                                        text = if (minutes == 1) stringResource(R.string.one_minute) else stringResource(R.string.x_minutes, minutes),&#10;                                        color = if (minutes == classReminderTimeMinutes)&#10;                                            MaterialTheme.colorScheme.primary&#10;                                        else MaterialTheme.colorScheme.onSurface&#10;                                    )&#10;                                },&#10;                                onClick = {&#10;                                    scope.launch {&#10;                                        notificationPreferencesManager.setClassReminderTimeMinutes(minutes)&#10;                                        notificationScheduler.scheduleClassReminders() // Reschedule with new time&#10;                                    }&#10;                                    showDropdown = false&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = stringResource(R.string.class_reminders),&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Text(&#10;                        text = stringResource(R.string.class_reminders_description),&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;                Switch(&#10;                    checked = classReminderNotificationsEnabled,&#10;                    enabled = notificationsEnabled,&#10;                    onCheckedChange = { enabled -&gt;&#10;                        scope.launch {&#10;                            notificationPreferencesManager.setClassReminderNotificationsEnabled(enabled)&#10;                            if (enabled) {&#10;                                notificationScheduler.scheduleClassReminders()&#10;                            } else {&#10;                                notificationScheduler.cancelClassReminders()&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;&#10;            // Time picker for reminder timing&#10;            if (classReminderNotificationsEnabled &amp;&amp; notificationsEnabled) {&#10;                var showDropdown by remember { mutableStateOf(false) }&#10;                val timeOptions = listOf(5, 10, 15, 30, 45, 60, 90, 120)&#10;&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable { showDropdown = true },&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                    )&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(12.dp),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically,&#10;                            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.AccessTime,&#10;                                contentDescription = null,&#10;                                tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                            Column {&#10;                                Text(&#10;                                    text = stringResource(R.string.reminder_time),&#10;                                    style = MaterialTheme.typography.bodyMedium,&#10;                                    fontWeight = FontWeight.Medium&#10;                                )&#10;                                Text(&#10;                                    text = stringResource(R.string.minutes_before_class, classReminderTimeMinutes),&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    DropdownMenu(&#10;                        expanded = showDropdown,&#10;                        onDismissRequest = { showDropdown = false }&#10;                    ) {&#10;                        timeOptions.forEach { minutes -&gt;&#10;                            DropdownMenuItem(&#10;                                text = {&#10;                                    Text(&#10;                                        text = if (minutes == 1) stringResource(R.string.one_minute) else stringResource(R.string.x_minutes, minutes),&#10;                                        color = if (minutes == classReminderTimeMinutes)&#10;                                            MaterialTheme.colorScheme.primary&#10;                                        else MaterialTheme.colorScheme.onSurface&#10;                                    )&#10;                                },&#10;                                onClick = {&#10;                                    scope.launch {&#10;                                        notificationPreferencesManager.setClassReminderTimeMinutes(minutes)&#10;                                        notificationScheduler.scheduleClassReminders() // Reschedule with new time&#10;                                    }&#10;                                    showDropdown = false&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.settingsScreen&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import de.fampopprol.dhbwhorb.data.notification.NotificationPreferencesManager&#10;import de.fampopprol.dhbwhorb.data.notification.NotificationScheduler&#10;import de.fampopprol.dhbwhorb.ui.screen.settingsScreen.classReminderSection.ClassReminderTimePicker&#10;import de.fampopprol.dhbwhorb.ui.screen.settingsScreen.classReminderSection.ClassReminderToggle&#10;&#10;@Composable&#10;fun ClassReminderSettingsSection(&#10;    notificationPreferencesManager: NotificationPreferencesManager,&#10;    notificationScheduler: NotificationScheduler,&#10;    notificationsEnabled: Boolean,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val classReminderNotificationsEnabled by notificationPreferencesManager.classReminderNotificationsEnabled.collectAsState(initial = false)&#10;    val classReminderTimeMinutes by notificationPreferencesManager.classReminderTimeMinutes.collectAsState(initial = 30)&#10;&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            ClassReminderToggle(&#10;                notificationPreferencesManager = notificationPreferencesManager,&#10;                notificationScheduler = notificationScheduler,&#10;                classReminderNotificationsEnabled = classReminderNotificationsEnabled,&#10;                notificationsEnabled = notificationsEnabled&#10;            )&#10;&#10;            // Show time picker only when reminders are enabled and notifications are allowed&#10;            if (classReminderNotificationsEnabled &amp;&amp; notificationsEnabled) {&#10;                ClassReminderTimePicker(&#10;                    notificationPreferencesManager = notificationPreferencesManager,&#10;                    notificationScheduler = notificationScheduler,&#10;                    classReminderTimeMinutes = classReminderTimeMinutes&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/settingsScreen/GeneralSettingsSection.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/settingsScreen/GeneralSettingsSection.kt" />
              <option name="originalContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.settingsScreen&#10;&#10;import android.os.Build&#10;import androidx.compose.foundation.clickable&#10;import android.os.Build&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Row&#10;import android.os.Build&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.DarkMode&#10;import androidx.compose.material.icons.filled.LightMode&#10;import androidx.compose.material.icons.filled.Palette&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Switch&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Row&#10;import android.os.Build&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.foundation.layout.padding&#10;import de.fampopprol.dhbwhorb.R&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Settings&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Switch&#10;import androidx.compose.material3.Text&#10;    val scope = rememberCoroutineScope()&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.ui.res.stringResource&#10;        // General Settings Header&#10;        Row(&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Settings,&#10;                contentDescription = null,&#10;                tint = MaterialTheme.colorScheme.primary&#10;            )&#10;            Text(&#10;                text = stringResource(R.string.general_settings),&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        }&#10;import androidx.compose.foundation.layout.padding&#10;import de.fampopprol.dhbwhorb.R&#10;import androidx.compose.material.icons.Icons&#10;        // Material You Theming Toggle (only show on Android 12+)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Column(modifier = Modifier.weight(1f)) {&#10;                            Text(&#10;                                text = stringResource(R.string.material_you_theming),&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                fontWeight = FontWeight.SemiBold&#10;                            )&#10;                            Text(&#10;                                text = stringResource(R.string.material_you_description),&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                        Switch(&#10;                            checked = materialYouEnabled,&#10;                            onCheckedChange = { enabled -&gt;&#10;                                scope.launch {&#10;                                    themePreferencesManager.setMaterialYouEnabled(enabled)&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;import androidx.compose.material3.Card&#10;        // Theme Mode Selection&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = when (themeMode) {&#10;                            ThemeMode.LIGHT -&gt; Icons.Default.LightMode&#10;                            ThemeMode.DARK -&gt; Icons.Default.DarkMode&#10;                            ThemeMode.SYSTEM -&gt; Icons.Default.Palette&#10;                        },&#10;                        contentDescription = null,&#10;                        tint = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = stringResource(R.string.theme_mode),&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.SemiBold&#10;                        )&#10;                        Text(&#10;                            text = stringResource(R.string.theme_mode_description),&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                }&#10;import androidx.compose.material3.Icon&#10;                // Theme mode selection buttons&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    ThemeMode.entries.forEach { mode -&gt;&#10;                        val isSelected = themeMode == mode&#10;                        Card(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .clickable {&#10;                                    scope.launch {&#10;                                        themePreferencesManager.setThemeMode(mode)&#10;                                    }&#10;                                },&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = if (isSelected)&#10;                                    MaterialTheme.colorScheme.primaryContainer&#10;                                else&#10;                                    MaterialTheme.colorScheme.surfaceVariant&#10;                            )&#10;                        ) {&#10;                            Column(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(12.dp),&#10;                                horizontalAlignment = Alignment.CenterHorizontally,&#10;                                verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                            ) {&#10;                                Icon(&#10;                                    imageVector = when (mode) {&#10;                                        ThemeMode.LIGHT -&gt; Icons.Default.LightMode&#10;                                        ThemeMode.DARK -&gt; Icons.Default.DarkMode&#10;                                        ThemeMode.SYSTEM -&gt; Icons.Default.Palette&#10;                                    },&#10;                                    contentDescription = null,&#10;                                    tint = if (isSelected)&#10;                                        MaterialTheme.colorScheme.onPrimaryContainer&#10;                                    else&#10;                                        MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                                Text(&#10;                                    text = stringResource(&#10;                                        when (mode) {&#10;                                            ThemeMode.LIGHT -&gt; R.string.theme_light&#10;                                            ThemeMode.DARK -&gt; R.string.theme_dark&#10;                                            ThemeMode.SYSTEM -&gt; R.string.theme_system&#10;                                        }&#10;                                    ),&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal,&#10;                                    color = if (isSelected)&#10;                                        MaterialTheme.colorScheme.onPrimaryContainer&#10;                                    else&#10;                                        MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.ui.res.stringResource&#10;        // General Settings Header&#10;        Row(&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Settings,&#10;                contentDescription = null,&#10;                tint = MaterialTheme.colorScheme.primary&#10;            )&#10;            Text(&#10;                text = stringResource(R.string.general_settings),&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        }&#10;import androidx.compose.foundation.layout.padding&#10;import de.fampopprol.dhbwhorb.R&#10;import androidx.compose.material.icons.Icons&#10;        // Material You Theming Toggle (only show on Android 12+)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Column(modifier = Modifier.weight(1f)) {&#10;                            Text(&#10;                                text = stringResource(R.string.material_you_theming),&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                fontWeight = FontWeight.SemiBold&#10;                            )&#10;                            Text(&#10;                                text = stringResource(R.string.material_you_description),&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                        Switch(&#10;                            checked = materialYouEnabled,&#10;                            onCheckedChange = { enabled -&gt;&#10;                                scope.launch {&#10;                                    themePreferencesManager.setMaterialYouEnabled(enabled)&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Theme Mode Selection&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = when (themeMode) {&#10;                            ThemeMode.LIGHT -&gt; Icons.Default.LightMode&#10;                            ThemeMode.DARK -&gt; Icons.Default.DarkMode&#10;                            ThemeMode.SYSTEM -&gt; Icons.Default.Palette&#10;                        },&#10;                        contentDescription = null,&#10;                        tint = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = stringResource(R.string.theme_mode),&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.SemiBold&#10;                        )&#10;                        Text(&#10;                            text = stringResource(R.string.theme_mode_description),&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                }&#10;import androidx.compose.material3.Icon&#10;                // Theme mode selection buttons&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    ThemeMode.entries.forEach { mode -&gt;&#10;                        val isSelected = themeMode == mode&#10;                        Card(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .clickable {&#10;                                    scope.launch {&#10;                                        themePreferencesManager.setThemeMode(mode)&#10;                                    }&#10;                                },&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = if (isSelected)&#10;                                    MaterialTheme.colorScheme.primaryContainer&#10;                                else&#10;                                    MaterialTheme.colorScheme.surfaceVariant&#10;                            )&#10;                        ) {&#10;                            Column(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(12.dp),&#10;                                horizontalAlignment = Alignment.CenterHorizontally,&#10;                                verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                            ) {&#10;                                Icon(&#10;                                    imageVector = when (mode) {&#10;                                        ThemeMode.LIGHT -&gt; Icons.Default.LightMode&#10;                                        ThemeMode.DARK -&gt; Icons.Default.DarkMode&#10;                                        ThemeMode.SYSTEM -&gt; Icons.Default.Palette&#10;                                    },&#10;                                    contentDescription = null,&#10;                                    tint = if (isSelected)&#10;                                        MaterialTheme.colorScheme.onPrimaryContainer&#10;                                    else&#10;                                        MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                                Text(&#10;                                    text = stringResource(&#10;                                        when (mode) {&#10;                                            ThemeMode.LIGHT -&gt; R.string.theme_light&#10;                                            ThemeMode.DARK -&gt; R.string.theme_dark&#10;                                            ThemeMode.SYSTEM -&gt; R.string.theme_system&#10;                                        }&#10;                                    ),&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal,&#10;                                    color = if (isSelected)&#10;                                        MaterialTheme.colorScheme.onPrimaryContainer&#10;                                    else&#10;                                        MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;        // General Settings Header&#10;        Row(&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Settings,&#10;                contentDescription = null,&#10;                tint = MaterialTheme.colorScheme.primary&#10;            )&#10;            Text(&#10;                text = stringResource(R.string.general_settings),&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        }&#10;import androidx.compose.ui.unit.dp&#10;import de.fampopprol.dhbwhorb.R&#10;import de.fampopprol.dhbwhorb.data.theme.ThemePreferencesManager&#10;        // Material You Theming Toggle (only show on Android 12+)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Column(modifier = Modifier.weight(1f)) {&#10;                            Text(&#10;                                text = stringResource(R.string.material_you_theming),&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                fontWeight = FontWeight.SemiBold&#10;                            )&#10;                            Text(&#10;                                text = stringResource(R.string.material_you_description),&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                        Switch(&#10;                            checked = materialYouEnabled,&#10;                            onCheckedChange = { enabled -&gt;&#10;                                scope.launch {&#10;                                    themePreferencesManager.setMaterialYouEnabled(enabled)&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Theme Mode Selection&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = when (themeMode) {&#10;                            ThemeMode.LIGHT -&gt; Icons.Default.LightMode&#10;                            ThemeMode.DARK -&gt; Icons.Default.DarkMode&#10;                            ThemeMode.SYSTEM -&gt; Icons.Default.Palette&#10;                        },&#10;                        contentDescription = null,&#10;                        tint = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = stringResource(R.string.theme_mode),&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.SemiBold&#10;                        )&#10;                        Text(&#10;                            text = stringResource(R.string.theme_mode_description),&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                }&#10;fun GeneralSettingsSection(&#10;                // Theme mode selection buttons&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    ThemeMode.entries.forEach { mode -&gt;&#10;                        val isSelected = themeMode == mode&#10;                        Card(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .clickable {&#10;                                    scope.launch {&#10;                                        themePreferencesManager.setThemeMode(mode)&#10;                                    }&#10;                                },&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = if (isSelected)&#10;                                    MaterialTheme.colorScheme.primaryContainer&#10;                                else&#10;                                    MaterialTheme.colorScheme.surfaceVariant&#10;                            )&#10;                        ) {&#10;                            Column(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(12.dp),&#10;                                horizontalAlignment = Alignment.CenterHorizontally,&#10;                                verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                            ) {&#10;                                Icon(&#10;                                    imageVector = when (mode) {&#10;                                        ThemeMode.LIGHT -&gt; Icons.Default.LightMode&#10;                                        ThemeMode.DARK -&gt; Icons.Default.DarkMode&#10;                                        ThemeMode.SYSTEM -&gt; Icons.Default.Palette&#10;                                    },&#10;                                    contentDescription = null,&#10;                                    tint = if (isSelected)&#10;                                        MaterialTheme.colorScheme.onPrimaryContainer&#10;                                    else&#10;                                        MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                                Text(&#10;                                    text = stringResource(&#10;                                        when (mode) {&#10;                                            ThemeMode.LIGHT -&gt; R.string.theme_light&#10;                                            ThemeMode.DARK -&gt; R.string.theme_dark&#10;                                            ThemeMode.SYSTEM -&gt; R.string.theme_system&#10;                                        }&#10;                                    ),&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal,&#10;                                    color = if (isSelected)&#10;                                        MaterialTheme.colorScheme.onPrimaryContainer&#10;                                    else&#10;                                        MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    val materialYouEnabled by themePreferencesManager.materialYouEnabled.collectAsState(initial = true)&#10;    val themeMode by themePreferencesManager.themeMode.collectAsState(initial = ThemeMode.SYSTEM)&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // General Settings Header&#10;        Row(&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Settings,&#10;                contentDescription = null,&#10;                tint = MaterialTheme.colorScheme.primary&#10;            )&#10;            Text(&#10;                text = stringResource(R.string.general_settings),&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Material You Theming Toggle (only show on Android 12+)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Column(modifier = Modifier.weight(1f)) {&#10;                            Text(&#10;                                text = stringResource(R.string.material_you_theming),&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                fontWeight = FontWeight.SemiBold&#10;                            )&#10;                            Text(&#10;                                text = stringResource(R.string.material_you_description),&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                        Switch(&#10;                            checked = materialYouEnabled,&#10;                            onCheckedChange = { enabled -&gt;&#10;                                scope.launch {&#10;                                    themePreferencesManager.setMaterialYouEnabled(enabled)&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Theme Mode Selection&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = when (themeMode) {&#10;                            ThemeMode.LIGHT -&gt; Icons.Default.LightMode&#10;                            ThemeMode.DARK -&gt; Icons.Default.DarkMode&#10;                            ThemeMode.SYSTEM -&gt; Icons.Default.Palette&#10;                        },&#10;                        contentDescription = null,&#10;                        tint = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = stringResource(R.string.theme_mode),&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.SemiBold&#10;                        )&#10;                        Text(&#10;                            text = stringResource(R.string.theme_mode_description),&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Theme mode selection buttons&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    ThemeMode.entries.forEach { mode -&gt;&#10;                        val isSelected = themeMode == mode&#10;                        Card(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .clickable {&#10;                                    scope.launch {&#10;                                        themePreferencesManager.setThemeMode(mode)&#10;                                    }&#10;                                },&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = if (isSelected)&#10;                                    MaterialTheme.colorScheme.primaryContainer&#10;                                else&#10;                                    MaterialTheme.colorScheme.surfaceVariant&#10;                            )&#10;                        ) {&#10;                            Column(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(12.dp),&#10;                                horizontalAlignment = Alignment.CenterHorizontally,&#10;                                verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                            ) {&#10;                                Icon(&#10;                                    imageVector = when (mode) {&#10;                                        ThemeMode.LIGHT -&gt; Icons.Default.LightMode&#10;                                        ThemeMode.DARK -&gt; Icons.Default.DarkMode&#10;                                        ThemeMode.SYSTEM -&gt; Icons.Default.Palette&#10;                                    },&#10;                                    contentDescription = null,&#10;                                    tint = if (isSelected)&#10;                                        MaterialTheme.colorScheme.onPrimaryContainer&#10;                                    else&#10;                                        MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                                Text(&#10;                                    text = stringResource(&#10;                                        when (mode) {&#10;                                            ThemeMode.LIGHT -&gt; R.string.theme_light&#10;                                            ThemeMode.DARK -&gt; R.string.theme_dark&#10;                                            ThemeMode.SYSTEM -&gt; R.string.theme_system&#10;                                        }&#10;                                    ),&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal,&#10;                                    color = if (isSelected)&#10;                                        MaterialTheme.colorScheme.onPrimaryContainer&#10;                                    else&#10;                                        MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.settingsScreen&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import de.fampopprol.dhbwhorb.data.theme.ThemePreferencesManager&#10;import de.fampopprol.dhbwhorb.ui.screen.settingsScreen.generalSettingsSection.GeneralSettingsHeader&#10;import de.fampopprol.dhbwhorb.ui.screen.settingsScreen.generalSettingsSection.MaterialYouToggle&#10;import de.fampopprol.dhbwhorb.ui.screen.settingsScreen.generalSettingsSection.ThemeModeSelector&#10;import de.fampopprol.dhbwhorb.ui.theme.ThemeMode&#10;&#10;@Composable&#10;fun GeneralSettingsSection(&#10;    themePreferencesManager: ThemePreferencesManager,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val materialYouEnabled by themePreferencesManager.materialYouEnabled.collectAsState(initial = true)&#10;    val themeMode by themePreferencesManager.themeMode.collectAsState(initial = ThemeMode.SYSTEM)&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        GeneralSettingsHeader()&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        MaterialYouToggle(&#10;            themePreferencesManager = themePreferencesManager,&#10;            materialYouEnabled = materialYouEnabled&#10;        )&#10;&#10;        ThemeModeSelector(&#10;            themePreferencesManager = themePreferencesManager,&#10;            themeMode = themeMode&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/settingsScreen/classReminderSection/ClassReminderTimePicker.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/settingsScreen/classReminderSection/ClassReminderTimePicker.kt" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.settingsScreen.classReminderSection&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.AccessTime&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.DropdownMenu&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import de.fampopprol.dhbwhorb.R&#10;import de.fampopprol.dhbwhorb.data.notification.NotificationPreferencesManager&#10;import de.fampopprol.dhbwhorb.data.notification.NotificationScheduler&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun ClassReminderTimePicker(&#10;    notificationPreferencesManager: NotificationPreferencesManager,&#10;    notificationScheduler: NotificationScheduler,&#10;    classReminderTimeMinutes: Int,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    var showDropdown by remember { mutableStateOf(false) }&#10;    val timeOptions = listOf(5, 10, 15, 30, 45, 60, 90, 120)&#10;&#10;    Card(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .clickable { showDropdown = true },&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(12.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.AccessTime,&#10;                    contentDescription = null,&#10;                    tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;                Column {&#10;                    Text(&#10;                        text = stringResource(R.string.reminder_time),&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Text(&#10;                        text = stringResource(R.string.minutes_before_class, classReminderTimeMinutes),&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        DropdownMenu(&#10;            expanded = showDropdown,&#10;            onDismissRequest = { showDropdown = false }&#10;        ) {&#10;            timeOptions.forEach { minutes -&gt;&#10;                DropdownMenuItem(&#10;                    text = {&#10;                        Text(&#10;                            text = if (minutes == 1) stringResource(R.string.one_minute) else stringResource(R.string.x_minutes, minutes),&#10;                            color = if (minutes == classReminderTimeMinutes)&#10;                                MaterialTheme.colorScheme.primary&#10;                            else MaterialTheme.colorScheme.onSurface&#10;                        )&#10;                    },&#10;                    onClick = {&#10;                        scope.launch {&#10;                            notificationPreferencesManager.setClassReminderTimeMinutes(minutes)&#10;                            notificationScheduler.scheduleClassReminders() // Reschedule with new time&#10;                        }&#10;                        showDropdown = false&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/settingsScreen/classReminderSection/ClassReminderToggle.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/settingsScreen/classReminderSection/ClassReminderToggle.kt" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.settingsScreen.classReminderSection&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Switch&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import de.fampopprol.dhbwhorb.R&#10;import de.fampopprol.dhbwhorb.data.notification.NotificationPreferencesManager&#10;import de.fampopprol.dhbwhorb.data.notification.NotificationScheduler&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun ClassReminderToggle(&#10;    notificationPreferencesManager: NotificationPreferencesManager,&#10;    notificationScheduler: NotificationScheduler,&#10;    classReminderNotificationsEnabled: Boolean,&#10;    notificationsEnabled: Boolean,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    Row(&#10;        modifier = modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.SpaceBetween,&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Column(modifier = Modifier.weight(1f)) {&#10;            Text(&#10;                text = stringResource(R.string.class_reminders),&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;            Text(&#10;                text = stringResource(R.string.class_reminders_description),&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;        Switch(&#10;            checked = classReminderNotificationsEnabled,&#10;            enabled = notificationsEnabled,&#10;            onCheckedChange = { enabled -&gt;&#10;                scope.launch {&#10;                    notificationPreferencesManager.setClassReminderNotificationsEnabled(enabled)&#10;                    if (enabled) {&#10;                        notificationScheduler.scheduleClassReminders()&#10;                    } else {&#10;                        notificationScheduler.cancelClassReminders()&#10;                    }&#10;                }&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/settingsScreen/generalSettingsSection/GeneralSettingsHeader.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/settingsScreen/generalSettingsSection/GeneralSettingsHeader.kt" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.settingsScreen.generalSettingsSection&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import de.fampopprol.dhbwhorb.R&#10;&#10;@Composable&#10;fun GeneralSettingsHeader(&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Row(&#10;        modifier = modifier,&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Default.Settings,&#10;            contentDescription = null,&#10;            tint = MaterialTheme.colorScheme.primary&#10;        )&#10;        Text(&#10;            text = stringResource(R.string.general_settings),&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/settingsScreen/generalSettingsSection/ThemeModeButton.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/settingsScreen/generalSettingsSection/ThemeModeButton.kt" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.settingsScreen.generalSettingsSection&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.DarkMode&#10;import androidx.compose.material.icons.filled.LightMode&#10;import androidx.compose.material.icons.filled.Palette&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import de.fampopprol.dhbwhorb.R&#10;import de.fampopprol.dhbwhorb.ui.theme.ThemeMode&#10;&#10;@Composable&#10;fun ThemeModeButton(&#10;    themeMode: ThemeMode,&#10;    isSelected: Boolean,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .clickable { onClick() },&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (isSelected)&#10;                MaterialTheme.colorScheme.primaryContainer&#10;            else&#10;                MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(12.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(4.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = when (themeMode) {&#10;                    ThemeMode.LIGHT -&gt; Icons.Default.LightMode&#10;                    ThemeMode.DARK -&gt; Icons.Default.DarkMode&#10;                    ThemeMode.SYSTEM -&gt; Icons.Default.Palette&#10;                },&#10;                contentDescription = null,&#10;                tint = if (isSelected)&#10;                    MaterialTheme.colorScheme.onPrimaryContainer&#10;                else&#10;                    MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;            Text(&#10;                text = stringResource(&#10;                    when (themeMode) {&#10;                        ThemeMode.LIGHT -&gt; R.string.theme_light&#10;                        ThemeMode.DARK -&gt; R.string.theme_dark&#10;                        ThemeMode.SYSTEM -&gt; R.string.theme_system&#10;                    }&#10;                ),&#10;                style = MaterialTheme.typography.bodySmall,&#10;                fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal,&#10;                color = if (isSelected)&#10;                    MaterialTheme.colorScheme.onPrimaryContainer&#10;                else&#10;                    MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/settingsScreen/generalSettingsSection/ThemeModeButtonRow.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/settingsScreen/generalSettingsSection/ThemeModeButtonRow.kt" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.settingsScreen.generalSettingsSection&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import de.fampopprol.dhbwhorb.data.theme.ThemePreferencesManager&#10;import de.fampopprol.dhbwhorb.ui.theme.ThemeMode&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun ThemeModeButtonRow(&#10;    themePreferencesManager: ThemePreferencesManager,&#10;    currentThemeMode: ThemeMode,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    Row(&#10;        modifier = modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;    ) {&#10;        ThemeMode.entries.forEach { mode -&gt;&#10;            ThemeModeButton(&#10;                themeMode = mode,&#10;                isSelected = currentThemeMode == mode,&#10;                onClick = {&#10;                    scope.launch {&#10;                        themePreferencesManager.setThemeMode(mode)&#10;                    }&#10;                },&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/settingsScreen/generalSettingsSection/ThemeModeHeader.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/de/fampopprol/dhbwhorb/ui/screen/settingsScreen/generalSettingsSection/ThemeModeHeader.kt" />
              <option name="updatedContent" value="/*&#10; * SPDX-FileCopyrightText: 2024 Joinside &lt;suitor-fall-life@duck.com&gt;&#10; *&#10; * SPDX-License-Identifier: AGPL-3.0-or-later&#10; */&#10;&#10;package de.fampopprol.dhbwhorb.ui.screen.settingsScreen.generalSettingsSection&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.DarkMode&#10;import androidx.compose.material.icons.filled.LightMode&#10;import androidx.compose.material.icons.filled.Palette&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import de.fampopprol.dhbwhorb.R&#10;import de.fampopprol.dhbwhorb.ui.theme.ThemeMode&#10;&#10;@Composable&#10;fun ThemeModeHeader(&#10;    currentThemeMode: ThemeMode,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Row(&#10;        modifier = modifier,&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        Icon(&#10;            imageVector = when (currentThemeMode) {&#10;                ThemeMode.LIGHT -&gt; Icons.Default.LightMode&#10;                ThemeMode.DARK -&gt; Icons.Default.DarkMode&#10;                ThemeMode.SYSTEM -&gt; Icons.Default.Palette&#10;            },&#10;            contentDescription = null,&#10;            tint = MaterialTheme.colorScheme.primary&#10;        )&#10;        Column(modifier = Modifier.weight(1f)) {&#10;            Text(&#10;                text = stringResource(R.string.theme_mode),&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.SemiBold&#10;            )&#10;            Text(&#10;                text = stringResource(R.string.theme_mode_description),&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>